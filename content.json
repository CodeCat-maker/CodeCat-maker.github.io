{"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"关于我-Codecat","text":"很高兴你能来我的 Blog 我只是一个写代码的猫君记录自己写代码的瞬间 希望自己越来越好 2021-09-10","link":"/about/index.html"}],"posts":[{"title":"k-NearestNeighbor","text":"KNN 近邻算法的初次实现和做法KNN 概述k-近邻（kNN, k-NearestNeighbor）算法是一种基本分类与回归方法，我们这里只讨论分类问题中的 k-近邻算法。 一句话总结: 近朱者赤近墨者黑！ k 近邻算法实际上利用训练数据集对特征向量空间进行划分，并作为其分类的“模型”。 k 值的选择、距离度量以及分类决策规则是 k 近邻算法的三个基本要素。 KNN 场景电影可以按照题材分类，那么如何区分 动作片 和 爱情片 呢？ 动作片: 打斗次数更多 爱情片: 亲吻次数更多 基于电影中的亲吻、打斗出现的次数，使用 k-近邻算法构造程序，就可以自动划分电影的题材类型。 KNN 原理KNN 工作原理 假设有一个带有标签的样本数据集（训练样本集），其中包含每条数据与所属分类的对应关系。 输入没有标签的新数据后，将新数据的每个特征与样本集中数据对应的特征进行比较。 计算新数据与样本数据集中每条数据的距离。 对求得的所有距离进行排序（从小到大，越小表示越相似）。 取前 k （k 一般小于等于 20 ）个样本数据对应的分类标签。 求 k 个数据中出现次数最多的分类标签作为新数据的分类。 KNN 通俗理解给定一个训练数据集，对新的输入实例，在训练数据集中找到与该实例最邻近的 k 个实例，这 k 个实例的多数属于某个类，就把该输入实例分为这个类。 KNN 算法的特点123优点: 精度高、对异常值不敏感、无数据输入假定缺点: 计算复杂度高、空间复杂度高适用数据范围: 数值型和标称型 KNN 算法初次实验123456789101112131415161718192021222324252627282930313233343536373839404142434445from numpy import *import operatorfrom os import listdirfrom collections import Counter#导入必要模块def createDataSet(): #创建数据集和标签 group = array([[1.0, 1.1], [1.0, 1.0], [0, 0], [0, 0.1]]) labels = ['A', 'A', 'B', 'B'] return group,labelsdef classify0(inX,dataSet,labels,k): #获取源数据矩阵的大小 dataSetSize = dataSet.shape[0] print(dataSetSize) print(tile(inX,(dataSetSize,1))) #生成矩阵差的值 diffMat = tile(inX,(dataSetSize,1)) - dataSet #取平方 sqDiffMat = diffMat ** 2 #对每一行都求和 sqDistances = sqDiffMat.sum(axis = 1) #对求和进行根号 distances = sqDistances ** 0.5 #根据距离进行排序从小到大进行排序，并且返回排序后的index sortedDisINdicies = distances.argsort() classCount = {} for i in range(k): #获取该元素的标签是什么 voteIlabel = labels[sortedDisINdicies[i]] #每出现一次，将这个标签+1 classCount[voteIlabel] = classCount.get(voteIlabel, 0) + 1 # 利用max函数直接返回字典中value最大的key maxClassCount = max(classCount,key = classCount.get) # 返回类型 return maxClassCountdef test1(): group,labels = createDataSet() display(group) display(labels) print(classify0([0.1,0.1],group,labels,3))test1() 部分文章出自https://github.com/apachecn/AiLearning/blob/master/docs/ml/2.md","link":"/2021/09/26/k-NearestNeighbor/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/09/10/hello-world/"},{"title":"并查集","text":"近似 O(1)的时间复杂度 并查集能解决什么问题？ 如何合并两个集合 如何两个元素在不在同一个区间内 并查集原理？用一棵树来存储整个集合，树根的编号就是整个集合的编号。每个节点存储它的父节点，p[x]代表它的父节点 衍生出问题 如何判断树根？if(p[x] == x) 如何求 x 的编号？while(p[x] != x) x = p[x] 如何合并两个集合，x 代表第一个集合，y 代表第二个集合？p[x] = y 如何优化？每遍历一次，让这个节点直接指向根节点，即可将时间复杂度优化为 O(1); 模版应用836. 合并集合 1234567891011121314151617181920212223242526272829303132import java.util.*;import java.io.*;public class Main{ private static int p[] = new int[100010]; //声明父节点; public static void main(String [] args) throws IOException { Scanner in = new Scanner(new BufferedInputStream(System.in)); BufferedWriter log = new BufferedWriter(new OutputStreamWriter(System.out)); int n = in.nextInt(); for(int i = 1 ; i &lt;= n ; i ++)p[i] = i; int m = in.nextInt(); while(m -- != 0){ String op = in.next(); if(op.equals(&quot;M&quot;)){ int a = in.nextInt(); int b = in.nextInt(); p[find(a)] = find(b); }else{ int a = in.nextInt(); int b = in.nextInt(); if(find(a) == find(b))log.write(&quot;Yes\\n&quot;); else log.write(&quot;No\\n&quot;); } } log.flush(); log.close(); } //查找x节点的父亲 public static int find(int x){ if(p[x] != x) p[x] = find(p[x]); return p[x]; }} 837. 连通块中点的数量同时维护当前区间内，有多少个数量 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.*;import java.io.*;public class Main{ public static int p[] = new int[100010]; public static int size[] = new int[100010]; public static void main(String[] args) throws IOException { Scanner in = new Scanner(new BufferedInputStream(System.in)); BufferedWriter log = new BufferedWriter(new OutputStreamWriter(System.out)); int n = in.nextInt(); int m = in.nextInt(); for(int i = 1 ; i &lt;= n ; i ++){ p[i] = i; size[i] = 1; } while(m -- != 0){ String op = in.next(); if(op.equals(&quot;C&quot;)){ int a = in.nextInt(); int b = in.nextInt(); if(find(a) == find(b)) continue; size[find(b)] += size[find(a)]; p[find(a)] = b; }else if(op.equals(&quot;Q1&quot;)){ int a = in.nextInt(); int b = in.nextInt(); if(find(a) == find(b))log.write(&quot;Yes\\n&quot;); else log.write(&quot;No\\n&quot;); }else{ int k = in.nextInt(); log.write(size[find(k)] + &quot;\\n&quot;); } } log.flush(); log.close(); } public static int find(int x){ if(p[x] != x)p[x] = find(p[x]); return p[x]; }} 240. 食物链 维护当前集合里面到根节点的距离 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import java.io.*;import java.util.*;public class Main{ public static int[] p,d; //p存储父节点 d存储距离 public static void main(String[] args) throws IOException{ Scanner in = new Scanner(new BufferedInputStream(System.in)); BufferedWriter log = new BufferedWriter(new OutputStreamWriter(System.out)); int n = in.nextInt(); int m = in.nextInt(); p = new int[n + 1]; d = new int[n + 1]; int ans = 0 ; //表示假话的个数 for(int i = 1 ; i &lt;= n ; i ++)p[i] = i; while(m -- != 0){ int op = in.nextInt(); int x = in.nextInt(); int y = in.nextInt(); if(x &gt; n || y &gt; n){ ans += 1; continue; } int px = find(x); int py = find(y); switch (op) { case 1 : { //同一个集合中，表示已确立相互关系 if (px == py) { if ((d[x] - d[y])%3 != 0) { ans++; continue; } } //不同集合中，现在建立相互关系 else { d[px] = d[y] - d[x]; p[px] = py; } break; } case 2 : { //同一个集合中，表示已确立相互关系 if (px == py) { //推导出的关系为 （d[x]-d[y]）%3 == 1 则认为x可以吃y //写成（d[x]-d[y]-1）%3 == 0 可以避免余数是负数的问题 //也可以写成（d[x]-d[y]）%3 +3 == 1 //==正确 -&gt; != 错误 if ((d[x] - d[y] - 1) % 3 != 0) { ans++; continue; } } //不同集合中，现在建立相互关系 else { d[px] = d[y] - d[x] + 1; p[px] = py; } break; } default : System.out.print(&quot;--&quot;); } } log.write(ans + &quot; &quot;); log.flush(); log.close(); } public static int find(int x){ if(x != p[x]){ int u = find(p[x]); d[x] += d[p[x]]; p[x] = u; } return p[x]; }}","link":"/2021/09/10/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"title":"堆排序","text":"堆分为小根堆和大根堆（本质上是一颗完全二叉树） 堆可以干什么？ 找到一个集合当中的最小值 删除一个集合当中的最小值 插入一个数 如何调整小根堆或者大根堆？以小根堆为例子 down -&gt; 选择这个数和子节点的最小值进行交换 up -&gt; 选择这个节点与父节点进行交换 如何存储堆？下标从 1 开始 保证了数组子节点的可行性 选择用数组的形式来存储 1 2 3 4 5 6 7 8k 的 子节点为 2k 2k+1 如何手写一个堆 插入一个数：heap[++size] = x; 求集合当中的最小元素：heap[1]; 删除最小的元素：heap[1] = heap[size]; size ++; down(1) //将末尾的元素覆盖到头节点，数组删除头节点是很麻烦的一件事 删除任意一个元素：heap[k] = heap[size]; size ++; down(k); up(k)； 修改任意一个元素：heap[k] = x;up(x);down(x); 保证 down 和 up 只执行一次 模版题838. 堆排序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.util.*;import java.io.*;public class Main{ public static int size = 0; public static int h[]; public static void main(String[] args) throws IOException{ Scanner in = new Scanner(new BufferedInputStream(System.in)); BufferedWriter log = new BufferedWriter(new OutputStreamWriter(System.out)); int n = in.nextInt(); int m = in.nextInt(); size = n; h = new int[n + 1]; for(int i = 1 ; i &lt;= n ; i ++){ h[i] = in.nextInt(); } //初始化小根堆 优化时间复杂度：nlogn -&gt; n for(int i = n/2 ; i != 0 ; i --){ down(i); } while(m -- != 0){ log.write(h[1] + &quot; &quot;); //删除最小值 h[1] = h[size]; size --; down(1); } log.flush(); log.close(); in.close(); } //向下调整小根堆 public static void down(int u){ int t = u; //用t来存储最小值的编号 if(u*2 &lt;= size &amp;&amp; h[u*2] &lt; h[t]) t = u * 2; if(u*2+1 &lt;= size &amp;&amp; h[u*2+1] &lt; h[t]) t = u * 2 + 1; if(t != u){ int c = h[t]; h[t] = h[u]; h[u] = c; down(t); //递归调整最小值 } } //向上调整小根堆 public static void up(int u){ while(u/2 != 0 &amp;&amp; h[u] &lt; h[u / 2]){ int c = h[u]; h[u] = h[u/2]; h[u/2] = c; u /= 2; } }} 839. 模拟堆 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import java.util.*;import java.io.*;class Main{ static BufferedReader read = new BufferedReader(new InputStreamReader(System.in)); static BufferedWriter log = new BufferedWriter(new OutputStreamWriter(System.out)); static int[] h; static int[] ph; //存放第k个插入点的下标 static int[] hp; //存放堆中点的插入次序 static int size; public static void main(String[] args) throws Exception{ int n = Integer.valueOf(read.readLine()); h = new int[n + 1]; ph = new int[n + 1]; hp = new int[n + 1]; size = 0; int m=0; //m用来记录插入的数的个数 while(n-- &gt; 0){ String[] s = read.readLine().split(&quot; &quot;); String op = s[0]; if(&quot;I&quot;.equals(op)){ int x = Integer.valueOf(s[1]); m++; h[++size]=x; ph[m]=size; hp[size]=m; //down(size); up(size); }else if(&quot;PM&quot;.equals(op)) log.write(h[1] + &quot;\\n&quot;); else if(&quot;DM&quot;.equals(op)){ heapSwap(1,size); size--; down(1); }else if(&quot;D&quot;.equals(op)){ int k = Integer.valueOf(s[1]); int u=ph[k]; //这里一定要用u=ph[k]保存第k个插入点的下标 heapSwap(u,size); //因为在此处heapSwap操作后ph[k]的值已经发生 size--; //如果在up,down操作中仍然使用ph[k]作为参数就会发生错误 up(u); down(u); }else if(&quot;C&quot;.equals(op)){ int k = Integer.valueOf(s[1]); int x = Integer.valueOf(s[2]); h[ph[k]]=x; //此处由于未涉及heapSwap操作且下面的up、down操作只会发生一个所以 down(ph[k]); //所以可直接传入ph[k]作为参数 up(ph[k]); } } log.flush(); } //这个交换过程其实有那么些绕 但关键是理解 如果hp[u]=k 则ph[k]=u 的映射关系 //之所以要进行这样的操作是因为 经过一系列操作 堆中的元素并不会保持原有的插入顺序 //从而我们需要对应到原先第K个堆中元素 //如果理解这个原理 那么就能明白其实三步交换的顺序是可以互换 //h,hp,ph之间两两存在映射关系 所以交换顺序的不同对结果并不会产生影响 public static void heapSwap(int u, int v){ swap(h,u,v); swap(hp, u, v); swap(ph, hp[u], hp[v]); } public static void swap(int[] a, int u, int v){ int tmp = a[u]; a[u] = a[v]; a[v] = tmp; } public static void down(int u){ int t = u; if(u * 2 &lt;= size &amp;&amp; h[t] &gt; h[u * 2]) t = u * 2; if(u * 2 + 1 &lt;= size &amp;&amp; h[t] &gt; h[u * 2 + 1]) t = u * 2 + 1; if(u != t){ heapSwap(u, t); down(t); } } public static void up(int u){ if(u / 2 &gt; 0 &amp;&amp; h[u] &lt; h[u / 2]){ heapSwap(u, u / 2); up(u/2); } }}","link":"/2021/09/11/%E5%A0%86%E6%8E%92%E5%BA%8F/"},{"title":"决策树","text":"1.划分数据集1.1 基本概念在度量数据集的无序程度的时候，分类算法除了需要测量信息熵，还需要划分数据集，度量花费数据集的熵，以便判断当前是否正确的划分了数据集。我们将对每个特征数据集划分的结果计算一次信息熵，然后判断按照那个特征划分数据集是最好的划分方式。也就是说，我们依次选取我们数据集当中的所有特征作为我们划定的特征，然后计算选取该特征时的信息增益，当信息增益最大时我们就选取对应信息增益最大的特征作为我们分类的最佳特征。 下面是我们的数据集：我们用 python 语言表示出这个数据集dataSet= [[1, 1, ‘yes’], [1, 1, ‘yes’], [1, 0, ‘no’], [0, 1, ‘no’], [0, 1, ‘no’]]在这个数据集当中有两个特征，就是每个样本的第一列和第二列，最后一列是它们所属的分类。 我们划分数据集是为了计算根据那个特征我们可以得到最大的信息增益，那么根据这个特征来划分数据就是最好的分类方法。 因此我们需要遍历每一个特征，然后计算按照这种划分方式得出的信息增益。信息增益是指数据集在划分数据前后信息的变化量。 1.2 具体操作划分数据集的方式我们首先选取第一个特征的第一个可能取值来筛选信息。然后再选取第一个特征的第二个可能的取值来划分我们的信息。之后我们再选取第二个特征的第一个可能的取值来划分数据集，以此类推。 e.g:[[1, 1, ‘yes’], [1, 1, ‘yes’], [1, 0, ‘no’], [0, 1, ‘no’], [0, 1, ‘no’]]这个是我们的数据集。如果我们选取第一个特征值也就是需不需要浮到水面上才能生存来划分我们的数据，这里生物有两种可能，1 就是需要，0 就是不需要。那么第一个特征的取值就是两种。 如果我们按照第一个特征的第一个可能的取值来划分数据也就是当所有的样本的第一列取 1 的时候满足的样本，那就是如下三个：[1, 1, ‘yes’], [1, 1, ‘yes’], [1, 0, ‘no’]可以理解为这个特征为一条分界线，我们选取完这个特征之后这个特征就要从我们数据集中剔除，因为要把他理解为分界线。那么划分好的数据就是： [[1, ‘yes’], [1, ‘yes’], [0, ‘no’]]如果我们以第一个特征的第二个取值来划分数据集，也就是当所有样本的第二列取 1 的时候满足的样本，那么就是 [[1, 1, ‘yes’], [1, 1, ‘yes’], [0, 1, ‘no’], [0, 1, ‘no’]]那么得到的数据子集就是下面这个样子：[[1,’yes’],[1,’yes’],[1, ‘no’], [1, ‘no’]]因此我们可以很容易的来构建出我们的代码： 下面我们来分析一下这段代码， 代码功能：划分数据集1234567891011def splitDataSet(dataSet,axis,value): #传入三个参数第一个参数是我们的数据集，是一个链表形式的数据集；第二个参数是我们的要依据某个特征来划分数据集retDataSet = [] #由于参数的链表 dataSet 我们拿到的是它的地址，也就是引用，直接在链表上操作会改变它的数值，所以我们新建一格链表来做操作for featVec in dataSet: if featVec[axis] == value: #如果某个特征和我们指定的特征值相等 #除去这个特征然后创建一个子特征 reduceFeatVec = featVec[:axis] reduceFeatVec.extend(featVec[axis+1:]) #将满足条件的样本并且经过切割后的样本都加入到我们新建立的样本中 retDataSet.append(reduceFeatVec)return retDataSet 12345678910111213总的来说，这段代码的功能就是按照某个特征的取值来划分数据集。 为方便您测试实验我们在贴出这段代码： 1234567891011def splitDataSet(dataSet,axis,value): retDataSet = [] for featVec in dataSet: if featVec[axis] == value: reduceFeatVec = featVec[:axis] reduceFeatVec.extend(featVec[axis+1:]) retDataSet.append(reduceFeatVec)return retDataSet#在这里我们可以注意到一个关于链表的操作：#那就是extend 和append 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126import numpy as npimport pandas as pdfrom math import *#构建数据集def createDataset(): dataSet = [[1, 1, 'yes'], [1, 1, 'yes'], [1, 0, 'no'], [0, 1, 'no'], [0, 1, 'no']] labels = ['no surfacing', 'flippers','is fish'] w1 = pd.DataFrame(dataSet,columns = labels) display(w1) return dataSet, labelscreateDataset()def calcShannoEnt(dataset): allnums = len(dataset) labels = {} for data in dataset: datalabel = data[-1] #初始化所有标签 if datalabel not in labels: labels[datalabel] = 0 labels[datalabel] += 1 hx = 0.0 for key in labels: #计算每种决策的概率 px = float(labels[key]/allnums) hx -= px * log(px,2) print(&quot;hx:&quot;,hx); #计算墒 return hxcalcShannoEnt(createDataset()[0])def splitDataSet(dataSet, index, value): retDataSet = [] for featVec in dataSet: # index列为value的数据集【该数据集需要排除index列】 # 判断index列的值是否为value if featVec[index] == value: # reducedFeatVec = featVec[:index] reducedFeatVec.extend(featVec[index+1:]) # [index+1:]表示从跳过 index 的 index+1行，取接下来的数据 # 收集结果值 index列为value的行【该行需要排除index列】 retDataSet.append(reducedFeatVec) #print(retDataSet) return retDataSetsplitDataSet(createDataset()[0],1,1)def chooseBestFeatureToSplit(dataSet): #需要进行多少次判断特征值 nums = len(dataSet[0]) - 1 baseEnt = calcShannoEnt(dataSet) bestInfoGain, bestFeature = 0.0, -1 for i in range(nums): #找出第一个特征值可能取得的值 featList = [example[i] for example in dataSet] print(&quot;featList:&quot;,featList) #将取得的值离散化 取出唯一值 uniqueList = set(featList) print(&quot;uniqueList&quot;,uniqueList) newE = 0.0 for j in uniqueList: #取出划分出来的子集 subDataset = splitDataSet(dataSet,i,j) print(&quot;subDataset:&quot;,subDataset) # 计算概率 prob = len(subDataset)/float(len(dataSet)) # 计算数学期望 newE += prob * calcShannoEnt(subDataset) #计算出信息增益 infoGain = baseEnt - newE print(f&quot;信息增益:{infoGain},特征值:{i}&quot;) if infoGain &gt; bestInfoGain: bestFeature = i bestInfoGain = infoGain #返回最优特征值 return bestFeaturechooseBestFeatureToSplit(createDataset()[0])def createTree(dataSet,labels): classList = [x[-1] for x in dataSet] #如果所有的标签都相同 就返回一个 if classList.count(classList[0]) == len(classList): return classList[0] #如果只有一列 则表明只有一类 if len(dataSet[0]) == 1: return majorityCnt(classList) bestFeat = chooseBestFeatureToSplit(dataSet) bestFeatLabel = labels[bestFeat] #创建决策树 myTree = {bestFeatLabel:{}} #删除同名变量 del(labels[bestFeat]) #选择最优列 作为分类依据 featValues = [x[bestFeat] for x in dataSet] uniqueVals = set(featValues) for i in uniqueVals: #拷贝一个标签labels副本 subLabels = labels[:] myTree[bestFeatLabel][i] = createTree(splitDataSet(dataSet,bestFeat,i),subLabels) return myTreea,b = createDataset()createTree(a,b)def test(moudelTree,featLabels,testVec): index = featLabels.index(list(moudelTree.keys())[0]) key = featLabels[index] val = testVec[index] print(f&quot;key:{key},val:{val}&quot;) newTree = moudelTree[key][val] print(newTree) if isinstance(newTree,dict): test(newTree,featLabels,testVec) else: return vala,b = createDataset()test(createTree(a,b),['no surfacing', 'flippers'],(1,1))","link":"/2021/10/03/%E5%86%B3%E7%AD%96%E6%A0%91/"},{"title":"哈希表","text":"近似 O(1)的时间复杂度 哈希表一般算法中处理的问题 插入一个数 查找一个数 删除一个数 实现哈希表的两种做法拉链法首先选择拉链法来解决问题，拉链法用通俗的话来说，就是数组+单链表的实现选择 hash 函数 将大整数 x 映射成为小整数的 840. 模拟散列表 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 100002;int e[N],ne[N],idx;int h[N];void insert(int x){ int y = (x % N + N) % N; //为了缩小y 同时也避免负数的存在 e[idx] = x; //在每一个数组下面拉出一条链 insert等同于单链表的操作 ne[idx] = h[y]; h[y] = idx++;}bool find(int x){ int y = (x % N + N ) % N; for(int i = h[y] ; i != -1 ; i = ne[i]) if(e[i] == x) return true; return false;}int main(){ int n; cin &gt;&gt; n; memset(h,-1,sizeof h); while(n --){ char op; int k; cin &gt;&gt; op &gt;&gt; k; if(op == 'I')insert(k); else{ if(find(k))puts(&quot;Yes&quot;); else puts(&quot;No&quot;); } } return 0;} 开放寻址法开放寻址法本质也是从前往后插入，比拉链法更简单的是它只需要开一个数组，操作和理解起来相对容易一点。开放寻址法从前往后找找到空的地方插入，如果已经有了就让当前这个位置的加一 840. 模拟散列表 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 200003,null = 0x3f3f3f3f;int h[N];int find(int x){ int t = (x % N + N)%N; while(h[t] != null &amp;&amp; h[t] != x){ t ++; if(t == N)t = 0; } return t;}int main(){ int n; cin &gt;&gt; n; memset(h,0x3f,sizeof h); while(n --){ char op; int x; cin &gt;&gt; op &gt;&gt; x; int k = find(x); if(op == 'I'){ h[k] = x; }else{ if(h[k] == null)puts(&quot;No&quot;); else puts(&quot;Yes&quot;); } } return 0;} 字符串哈希(字符串哈希) O(n)+O(m) 全称字符串前缀哈希法，把字符串变成一个 p 进制数字（哈希值），实现不同的字符串映射到不同的数字。对形如 X1X2X3⋯Xn−1Xn的字符串,采用字符的 ascii 码乘上 P 的次方来计算哈希值。 映射公式 (X1×Pn−1+X2×Pn−2+⋯+Xn−1×P1+Xn×P0)modQ 注意点： 任意字符不可以映射成 0，否则会出现不同的字符串都映射成 0 的情况，比如 A,AA,AAA 皆为 0 冲突问题：通过巧妙设置 P (131 或 13331) , Q (264)的值，一般可以理解为不产生冲突。 问题是比较不同区间的子串是否相同，就转化为对应的哈希值是否相同。求一个字符串的哈希值就相当于求前缀和，求一个字符串的子串哈希值就相当于求部分和。 前缀和公式 h[i+1]=h[i]×P+s[i]i∈[0,n−1]h 为前缀和数组，s 为字符串数组区间和公式 h[l,r]=h[r]−h[l−1]×Pr−l+1 区间和公式的理解: ABCDE 与 ABC 的前三个字符值是一样，只差两位，乘上 P2把 ABC 变为 ABC00，再用 ABCDE - ABC00 得到 DE 的哈希值。 作者：chocolate-emperor链接：https://www.acwing.com/solution/content/24738/来源：AcWing著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 841. 字符串哈希 123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;typedef unsigned long long ULL;const int N = 100010,P = 131;ULL p[N],h[N];ULL get(int l,int r){ return h[r] - h[l-1]*p[r-l+1];}int main(){ int n,m; string str; cin &gt;&gt; n &gt;&gt; m &gt;&gt; str; p[0] = 1; h[0] = 0; for(int i = 1 ; i &lt;= n ; i ++){ p[i] = p[i-1] * P; h[i] = h[i-1] * P + str[i - 1]; } while(m -- != 0){ int l1,r1,l2,r2; cin &gt;&gt; l1 &gt;&gt; r1 &gt;&gt; l2 &gt;&gt; r2; if(get(l1,r1) != get(l2,r2))puts(&quot;No&quot;); else puts(&quot;Yes&quot;); } return 0;}","link":"/2021/09/20/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"title":"排序算法","text":"三种排序[选择，归并，冒泡]选择排序优点：处理小数据的时候很快，时间复杂度(O^2) 选择排序就跟扑克牌一样，从牌堆里面选择一张牌插入到牌中，依次选择手中的牌，把相对较小的插入到其中 1234567891011void insertionSort(int arr[]){ for(int i = 0 ; i &lt; 6 ; i ++){ int key = arr[i]; int j = i - 1; while(j &gt;= 0 &amp;&amp; arr[j] &gt; key){ arr[j + 1] = arr[j]; j --; } arr[j + 1] = key; }} 快速排序时间复杂度为 O(nlogn) 12345678910111213void quick_sort(int q[], int l, int r){ if (l &gt;= r) return; int i = l - 1, j = r + 1, x = q[l + r &gt;&gt; 1]; while (i &lt; j) { do i ++ ; while (q[i] &lt; x); do j -- ; while (q[j] &gt; x); if (i &lt; j) swap(q[i], q[j]); } quick_sort(q, l, j), quick_sort(q, j + 1, r);} 归并排序**时间复杂度 O(n log n) ** 123456789101112131415161718192021222324void mergeSort(int arr[], int l, int r){ if (l &gt;= r) return; int mid = (l + r) / 2; mergeSort(arr, l, mid); mergeSort(arr, mid + 1, r); int k = 0, i = l, j = mid + 1; int tmp[r - l + 1]; while (i &lt;= mid &amp;&amp; j &lt;= r) { if (arr[i] &lt; arr[j]) tmp[k++] = arr[i++]; else tmp[k++] = arr[j++]; } while (i &lt;= mid) tmp[k++] = arr[i++]; while (j &lt;= r) tmp[k++] = arr[j++]; for (i = l, j = 0; i &lt;= r; i++, j++) arr[i] = tmp[j];} 快速排序和快速排序都是分治思想","link":"/2021/09/24/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"title":"归一化","text":"什么是归一化？以实际例子来说，在国家贸易中，各个国家的货币价值不一样，当 A 国想买 10 吨煤的时候，我们一般是先将钱转化为美元，再用美元去买 10 吨煤，这样中间就有了一个标准 归一化有什么用？归一化在处理数学问题和权重问题的时候具有实用的意义，比如说大学生自习室安排问题中，宿舍距各教室路线长短，教室大小，照明质量，满座率等都是影响结果的因素，这些因素本身有一个相对值，但没有一个统一的标准去衡量他们，于是出现了归一化。使每个大因素和小变量之间都有了一个桥梁，合理的去参与到对决策的影响中。","link":"/2021/09/25/%E5%BD%92%E4%B8%80%E5%8C%96/"},{"title":"浅谈c++的深拷贝与浅拷贝","text":"初次见面正如字面意思，深与浅无非是拷贝力度的大小。那么怎么理解深和浅呢？ 深：将拷贝对象的所有属性复制一遍 浅：仅拷贝对象的地址 那么为什么要有浅拷贝与深拷贝呢？ 总的目的来说，浅拷贝是为了提高速率，让程序员可以直接操纵对象地址，不用再花时间与内存去复制一份新的出来。显而易见可以看出浅拷贝是很方便操作的。 既然浅拷贝很好 那么我不防聊一聊它的坏处 浅拷贝的坏处程序在设计的初期，并不希望我们把所有的事情都考虑好，更希望程序在运行的过程中自行的去拓展。例如我们要存储一个学生的信息，难道我们一开始就要把学生的最高使用上限就考虑到么，肯定不是的。所以出现了 new 和 delete 。使用 new 创建的变量会放在计算机内存的一个特定部分，直到 delete 调用后这个变量才会删除。这是 new 和 delete 使用的背景。 例子1234567891011121314151617#ifndef STRNGBAD_H__#define STRNGBAD_H__#include &lt;iostream&gt;class StringBad{private: char *str; int len; static int num_strings;public: StringBad(); StringBad(const char *s); ~StringBad(); friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const StringBad &amp;st);};#endif 1234567891011121314151617181920212223242526272829303132333435#include &lt;cstring&gt;#include &quot;strngbad.h&quot;using std::cout;int StringBad::num_strings = 0;StringBad::StringBad(const char *s){ len = std::strlen(s); str = new char[len + 1]; std::strcpy(str, s); num_strings++; cout &lt;&lt; num_strings &lt;&lt; &quot;: \\&quot;&quot; &lt;&lt; str &lt;&lt; &quot;\\&quot; default object created\\n&quot;;}StringBad::StringBad(){ len = 4; str = new char[4]; std::strcpy(str, &quot;c++&quot;); num_strings++; cout &lt;&lt; num_strings &lt;&lt; &quot;: \\&quot;&quot; &lt;&lt; str &lt;&lt; &quot;\\&quot; default object created\\n&quot;;}StringBad::~StringBad(){ cout &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; str &lt;&lt; &quot;\\&quot; object deleted, &quot;; --num_strings; cout &lt;&lt; num_strings &lt;&lt; &quot;left\\n&quot;; delete[] str;}std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const StringBad &amp;st){ os &lt;&lt; st.str; return os;} main.cpp 123456789101112131415161718192021222324252627282930313233343536373839#include &quot;strngbad.h&quot;using std::cout;using std::endl;void callme1(StringBad &amp;);void callme2(StringBad);int main(){ { cout &lt;&lt; &quot;Start&quot; &lt;&lt; endl; StringBad headline1(&quot;Celery Stalk at Midnight&quot;); StringBad headline2(&quot;Lecttuce Prey&quot;); StringBad sports(&quot;Spinach Leaves Bowl for Dollars&quot;); cout &lt;&lt; &quot;head1&quot; &lt;&lt; headline1 &lt;&lt; endl; callme1(headline1); cout &lt;&lt; &quot;head2&quot; &lt;&lt; headline2 &lt;&lt; endl; callme2(headline2); StringBad sailor = sports; cout &lt;&lt; sailor &lt;&lt; endl; StringBad knot; knot = headline1; cout &lt;&lt; knot &lt;&lt; endl; cout &lt;&lt; &quot;exit&quot;; } cout &lt;&lt; &quot;end main&quot;; return 0;}void callme1(StringBad &amp;rsb){ cout &lt;&lt; &quot;String pass by references:\\n&quot;; cout &lt;&lt; &quot;rsb:&quot; &lt;&lt; rsb &lt;&lt; endl;}void callme2(StringBad sb){ cout &lt;&lt; &quot;String pass by references:\\n&quot;; cout &lt;&lt; &quot;sb:&quot; &lt;&lt; sb &lt;&lt; endl;} 当我们编译之后发现程序并没有错误，可是当程序运行的时候，程序会报错，触发了 GPF 错误（GPF 表示程序试图访问禁止的内存单元）这是一种很坏的现象。 1234567891011121314151617181920Start1: &quot;Celery Stalk at Midnight&quot; default object created2: &quot;Lecttuce Prey&quot; default object created3: &quot;Spinach Leaves Bowl for Dollars&quot; default object createdhead1Celery Stalk at MidnightString pass by references:rsb:Celery Stalk at Midnighthead2Lecttuce PreyString pass by references:sb:Lecttuce Prey&quot;Lecttuce Prey&quot; object deleted, 2leftSpinach Leaves Bowl for Dollars3: &quot;c++&quot; default object createdCelery Stalk at Midnightexit&quot;Celery Stalk at Midnight&quot; object deleted, 2left&quot;Spinach Leaves Bowl for Dollars&quot; object deleted, 1left&quot;@Q�eC#&quot; object deleted, 0lefta.out(14353,0x1048b4580) malloc: *** error for object 0x6000011c5140: pointer being freed was not allocateda.out(14353,0x1048b4580) malloc: *** set a breakpoint in malloc_error_break to debugzsh: abort ./a.out 关于为什么会出现错误呢？1.Private 里的 num_strings 错误这种错误主要是程序调用 c++里的默认拷贝函数，复制了一份新的 StringBad 对象，而 Static 静态类型属于整个类并不属于某个对象，故临时产生的 StringBad 对象也会调用析构函数从而导致 num_strings – 2.@Q�eC# 文字乱码12345StringBad sports;sports = headline1;等同于： sports.str = headline1.str;sports.len = headline1.len; 我们可以发现其中 sports.str 只是指向了 headline1.str 的地址，但是由于 headlline1 在销毁的时候会调用 delete 将 str 从内存中删除掉，从而 sports.str 没有地址可寻. 如何解决？创建复制构造函数 1234567StringBad::StringBad(const StringBad &amp; st){ num_strings ++; len = st.len; str = new char [len + 1]; cout &lt;&lt; num_strings &lt;&lt; &quot;: \\&quot;&quot; &lt;&lt; str &lt;&lt; &quot;\\&quot; object created\\n&quot;;}","link":"/2022/02/13/%E6%B5%85%E8%B0%88c-%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/"}],"tags":[{"name":"KNN","slug":"KNN","link":"/tags/KNN/"},{"name":"并查集","slug":"并查集","link":"/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"堆排序","slug":"堆排序","link":"/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/"},{"name":"决策树","slug":"决策树","link":"/tags/%E5%86%B3%E7%AD%96%E6%A0%91/"},{"name":"哈希表","slug":"哈希表","link":"/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"选择排序","slug":"选择排序","link":"/tags/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"},{"name":"归并排序","slug":"归并排序","link":"/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"name":"冒泡排序","slug":"冒泡排序","link":"/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"},{"name":"归一化","slug":"归一化","link":"/tags/%E5%BD%92%E4%B8%80%E5%8C%96/"},{"name":"c++","slug":"c","link":"/tags/c/"}],"categories":[{"name":"MachineLea","slug":"MachineLea","link":"/categories/MachineLea/"},{"name":"algorithm","slug":"algorithm","link":"/categories/algorithm/"}]}