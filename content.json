{"pages":[{"title":"关于我-Codecat","text":"很高兴你能来我的 Blog 我只是一个写代码的猫君记录自己写代码的瞬间 希望自己越来越好 2021-09-10","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"安卓逆向学习之frida基础用法","text":"frida 是一款方便并且易用的跨平台 Hook 工具，使用它不仅可以 Hook Java 写的应用程序，而且还可以 Hook 原生的应用程序。 frida 分客户端环境和服务端环境。在客户端我们可以编写 Python 代码，用于连接远程设备，提交要注入的代码到远程，接受服务端的发来的消息等。在服务端，我们需要用 Javascript 代码注入到目标进程，操作内存数据，给客户端发送消息等操作。我们也可以把客户端理解成控制端，服务端理解成被控端。假如我们要用 PC 来对 Android 设备上的某个进程进行操作，那么 PC 就是客户端，而 Android 设备就是服务端。 1.1 准备 frida 服务端环境本文，服务端在 Android 平台测试。服务端环境准备步骤如下： 根据自己的平台下载 frida 服务端并解压https://github.com/frida/frida/releases frida_server 2. 执行以下命令将服务端推到手机的/data/local/tmp 目录adb push frida-server /data/local/tmp/frida-server 3. 执行以下命令修改 frida-server 文件权限adb shell chmod 777 /data/local/tmp/frida-server 注：Windows 系统执行命令可以在 CMD 中进行；Linux 和 MacOS 执行命令可以在终端中进行。adb 是 Android 一个调试工具，具体安装方法不是本文的重点。 1.2 准备客户端环境在 PC 上安装 Python 的运行环境，安装完成后执行下面的命令安装 frida pip install frida 1.3 客户端命令参数下面是 frida 客户端命令行的参数解释，看一下就好 Usage: frida [options] target Options: --version show program's version number and exit -h, --help show this help message and exit -D ID, --device=ID connect to device with the given ID -U, --usb connect to USB device -R, --remote connect to remote frida-server -H HOST, --host=HOST connect to remote frida-server on HOST -f FILE, --file=FILE spawn FILE -n NAME, --attach-name=NAME attach to NAME -p PID, --attach-pid=PID attach to PID --debug enable the Node.js compatible script debugger --enable-jit enable JIT -l SCRIPT, --load=SCRIPT load SCRIPT -c CODESHARE_URI, --codeshare=CODESHARE_URI load CODESHARE_URI -e CODE, --eval=CODE evaluate CODE -q quiet mode (no prompt) and quit after -l and -e --no-pause automatically start main thread after startup -o LOGFILE, --output=LOGFILE output to log file 如果将一个脚本注入到 Android 目标进程 frida -U -l myhook.js com.xxx.xxxx 参数解释： -U 指定对 USB 设备操作 -l 指定加载一个 Javascript 脚本 最后指定一个进程名，如果想指定进程 pid,用-p选项。正在运行的进程可以用frida-ps -U命令查看 frida 运行过程中，执行%resume重新注入，执行%reload来重新加载脚本；执行exit结束脚本注入 2. Hook Java 方法2.1 载入类Java.use 方法用于声明一个 Java 类，在用一个 Java 类之前首先得声明。比如声明一个 String 类，要指定完整的类名： var StringClass=Java.use(&quot;java.lang.String&quot;); 2.2 修改函数的实现修改一个函数的实现是逆向调试中相当有用的。修改一个函数的实现后，如果这个函数被调用，我们的 Javascript 代码里的函数实现也会被调用。 2.2.1 函数参数类型表示不同的参数类型都有自己的表示方法 对于基本类型，直接用它在 Java 中的表示方法就可以了，不用改变，例如： int short char byte boolean float double long 基本类型数组，用左中括号接上基本类型的缩写 基本类型缩写表示表： 基本类型缩写 booleanZbyteBcharCdoubleDfloatFintIlongJshortS 例如：int[]类型，在重载时要写成[I 任意类，直接写完整类名即可 例如：java.lang.String 对象数组，用左中括号接上完整类名再接上分号 例如：[java.lang.String; 2.2.2 带参数的构造函数修改参数为 byte[]类型的构造函数的实现 ClassName.$init.overload('[B').implementation=function(param){ //do something } 注：ClassName 是使用 Java.use 定义的类;param 是可以在函数体中访问的参数 修改多参数的构造函数的实现 ClassName.$init.overload('[B','int','int').implementation=function(param1,param2,param3){ //do something } 2.2.3 无参数构造函数ClassName.$init.overload().implementation=function(){ //do something } 调用原构造函数 ClassName.$init.overload().implementation=function(){ //do something this.$init(); //do something } 注意：当构造函数(函数)有多种重载形式，比如一个类中有两个形式的 func：void func()和void func(int)，要加上 overload 来对函数进行重载，否则可以省略 overload 2.2.4 一般函数修改函数名为 func，参数为 byte[]类型的函数的实现 ClassName.func.overload('[B').implementation=function(param){ //do something //return ... } 2.2.5 无参数的函数ClassName.func.overload().implementation=function(){ //do something } 注： 在修改函数实现时，如果原函数有返回值，那么我们在实现时也要返回合适的值 ClassName.func.overload().implementation=function(){ //do something return this.func(); } 3. 调用函数和 Java 一样，创建类实例就是调用构造函数，而在这里用$new表示一个构造函数。 var ClassName=Java.use(&quot;com.luoye.test.ClassName&quot;); var instance = ClassName.$new(); 实例化以后调用其他函数 var ClassName=Java.use(&quot;com.luoye.test.ClassName&quot;); var instance = ClassName.$new(); instance.func(); 4. 类型转换用Java.cast方法来对一个对象进行类型转换，如将variable转换成java.lang.String： var StringClass=Java.use(&quot;java.lang.String&quot;); var NewTypeClass=Java.cast(variable,StringClass); 5. Java.available 字段这个字段标记 Java 虚拟机（例如： Dalvik 或者 ART）是否已加载, 操作 Java 任何东西之前，要确认这个值是否为 true 6. Java.perform 方法Java.perform(fn)在 Javascript 代码成功被附加到目标进程时调用，我们核心的代码要在里面写。格式： Java.perform(function(){ //do something... }); 7. 实例讲解有了以上的基础知识，我们就可以进行编写代码了 7.1 修改返回值7.1.1 场景假设有以下的程序，给 isExcellent 方法传入两个值，通过计算，返回一个布尔值，表示是否优秀。默认情况下，它是只会显示是否优秀：false的，因为我们默认传入的数很小: exp1_before public class MainActivity extends AppCompatActivity { private String TAG=&quot;Crackme&quot;; private TextView textView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView =findViewById(R.id.tv); textView.setText(&quot;是否优秀：&quot;+isExcellent(46,54)); } private boolean isExcellent(int chinese, int math){ if( chinese + math &gt;=180){ return true; } else{ return false; } } } 我们编写一个脚本来 Hook isExcellent 函数，使它返回 true，显示为是否优秀：true 对于这种简单的场景，直接修改返回值就可以了，因为只有结果是重要的。 7.1.2 代码想直接返回结果很简单，直接在匿名方法里 return 即可。 if(Java.available){ Java.perform(function(){ var MainActivity = Java.use(&quot;com.luoyesiqiu.crackme.MainActivity&quot;); MainActivity.isExcellent.implementation=function(){ return true; } }); } 将上面的代码保存为：exp1.js 执行adb shell 'su -c /data/local/tmp/frida-server'启动服务端 运行目标 App 执行frida -U -l exp1.js com.luoyesiqiu.crackme注入代码 按返回键返回桌面，再重新打开 App,发现达到预期 在命令行输入exit，回车，停止注入代码 exp1_after 注：这里为什么要打开两次 App？第一打开是为了让 frida 能够找到进程，第二次打开是为了验证结果，即使 Hook 成功了，界面是有缓存的，并不能实时显示 Hook 结果，所以需要重新打开 App 7.2 修改参数7.2.1 场景假设有以下场景，isExcellent 除了返回是否优秀以外，方法的内部还把分数打印出来。 exp2_before public class MainActivity extends AppCompatActivity { private String TAG=&quot;Crackme&quot;; private TextView textView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView =findViewById(R.id.tv); textView.append(&quot;是否优秀：&quot;+isExcellent(46,54)+&quot;\\n&quot;); } private boolean isExcellent(int chinese, int math){ textView.append(&quot;语文+数学总分：&quot;+(chinese+math)+&quot;\\n&quot;); if( chinese + math &gt;=180){ return true; } else{ return false; } } } 这种情况下我们不可能只返回是否优秀吧，显示的总分很低，但是却返回优秀，是很尴尬的…所以我们要修改 isExcellent 方法的参数，使其通过计算打印和返回合理的值。 7.2.2 代码if(Java.available){ Java.perform(function(){ var MainActivity = Java.use(&quot;com.luoyesiqiu.crackme.MainActivity&quot;); MainActivity.isExcellent.overload(&quot;int&quot;,&quot;int&quot;).implementation=function(chinese,math){ return this.isExcellent(95,96); } }); } 上面的代码，通过 overload 方法重载参数，修改 isExcellent 方法实现，并在实现函数里调用原来的方法，得到新的返回值 将上面的代码保存为：exp2.js 执行adb shell 'su -c /data/local/tmp/frida-server'启动服务端（如果上面启动的服务端还开着可省略这一步） 运行目标 App 执行frida -U -l exp2.js com.luoyesiqiu.crackme注入代码 按返回键，再重新打开 App,发现达到预期 在命令行输入exit，回车，停止注入代码 exp2_after 8. 配合 Python 脚本注入在本文刚开始的时候说到，我们可以编写 Python 代码来配合 Javascript 代码注入。下面我们来看看，怎么使用，先看一段代码： # -*- coding: UTF-8 -*- import frida, sys jscode = &quot;&quot;&quot; if(Java.available){ Java.perform(function(){ var MainActivity = Java.use(&quot;com.luoyesiqiu.crackme.MainActivity&quot;); MainActivity.isExcellent.overload(&quot;int&quot;,&quot;int&quot;).implementation=function(chinese,math){ console.log(&quot;[javascript] isExcellent be called.&quot;); send(&quot;isExcellent be called.&quot;); return this.isExcellent(95,96); } }); } &quot;&quot;&quot; def on_message(message, data): if message['type'] == 'send': print(&quot;[*] {0}&quot;.format(message['payload'])) else: print(message) pass # 查找USB设备并附加到目标进程 session = frida.get_usb_device().attach('com.luoyesiqiu.crackme') # 在目标进程里创建脚本 script = session.create_script(jscode) # 注册消息回调 script.on('message', on_message) print('[*] Start attach') # 加载创建好的javascript脚本 script.load() # 读取系统输入 sys.stdin.read() 将上面的代码，保存为exp3.py 执行adb shell 'su -c /data/local/tmp/frida-server'启动服务端（如果上面启动的服务端还开着可省略这一步） 运行目标 App 执行python exp3.py注入代码 按返回键，再重新打开 App,发现达到预期 按Ctrl+C停止脚本和停止注入代码 上面是一段 Python 代码，我们来分析它的步骤： 通过调用frida.get_usb_device()方法来得到一个连接中的 USB 设备（Device 类）实例 调用 Device 类的attach()方法来附加到目标进程并得到一个会话（Session 类）实例，该方法有一个参数，参数是需要注入的进程名或者进程 pid。如果需要 Hook 的代码在 App 的启动期执行，那么在调用 attach 方法前需要先调用 Device 类的spawn()方法，这个方法也有一个参数，参数是进程名，该方法调用后会重启对应的进程，并返回新的进程 pid。得到新的进程 pid 后，我们可以将这个进程 pid 传递给attach()方法来实现附加。 接着调用 Session 类的create_script()方法创建一个脚本，传入需要注入的 javascript 代码并得到 Script 类实例 调用 Script 类的on()方法添加一个消息回调，第一个参数是信号名，乖乖传入message就行，第二个是回调函数 最后调用 Script 类的load()方法来加载刚才创建的脚本。 注：如果想在 javascript 输出日志，可以调用console.log()方法。如果想给客户端发送消息，可以在 javascript 代码里调用send()方法，并在客户端 Python 代码里注册一个消息回调来接收服务端发来的消息。 可以看到，结合 python 代码，使注入更加的灵活了。如果想看 Python 端 frida 模块的代码，可以访问：https://github.com/frida/frida-python/blob/master/frida/core.py 9. 参考 https://www.frida.re/docs/home/","link":"/2022/06/13/frida%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/"},{"title":"决策树","text":"1.划分数据集1.1 基本概念在度量数据集的无序程度的时候，分类算法除了需要测量信息熵，还需要划分数据集，度量花费数据集的熵，以便判断当前是否正确的划分了数据集。我们将对每个特征数据集划分的结果计算一次信息熵，然后判断按照那个特征划分数据集是最好的划分方式。也就是说，我们依次选取我们数据集当中的所有特征作为我们划定的特征，然后计算选取该特征时的信息增益，当信息增益最大时我们就选取对应信息增益最大的特征作为我们分类的最佳特征。 下面是我们的数据集：我们用 python 语言表示出这个数据集dataSet= [[1, 1, ‘yes’], [1, 1, ‘yes’], [1, 0, ‘no’], [0, 1, ‘no’], [0, 1, ‘no’]]在这个数据集当中有两个特征，就是每个样本的第一列和第二列，最后一列是它们所属的分类。 我们划分数据集是为了计算根据那个特征我们可以得到最大的信息增益，那么根据这个特征来划分数据就是最好的分类方法。 因此我们需要遍历每一个特征，然后计算按照这种划分方式得出的信息增益。信息增益是指数据集在划分数据前后信息的变化量。 1.2 具体操作划分数据集的方式我们首先选取第一个特征的第一个可能取值来筛选信息。然后再选取第一个特征的第二个可能的取值来划分我们的信息。之后我们再选取第二个特征的第一个可能的取值来划分数据集，以此类推。 e.g:[[1, 1, ‘yes’], [1, 1, ‘yes’], [1, 0, ‘no’], [0, 1, ‘no’], [0, 1, ‘no’]]这个是我们的数据集。如果我们选取第一个特征值也就是需不需要浮到水面上才能生存来划分我们的数据，这里生物有两种可能，1 就是需要，0 就是不需要。那么第一个特征的取值就是两种。 如果我们按照第一个特征的第一个可能的取值来划分数据也就是当所有的样本的第一列取 1 的时候满足的样本，那就是如下三个：[1, 1, ‘yes’], [1, 1, ‘yes’], [1, 0, ‘no’]可以理解为这个特征为一条分界线，我们选取完这个特征之后这个特征就要从我们数据集中剔除，因为要把他理解为分界线。那么划分好的数据就是： [[1, ‘yes’], [1, ‘yes’], [0, ‘no’]]如果我们以第一个特征的第二个取值来划分数据集，也就是当所有样本的第二列取 1 的时候满足的样本，那么就是 [[1, 1, ‘yes’], [1, 1, ‘yes’], [0, 1, ‘no’], [0, 1, ‘no’]]那么得到的数据子集就是下面这个样子：[[1,’yes’],[1,’yes’],[1, ‘no’], [1, ‘no’]]因此我们可以很容易的来构建出我们的代码： 下面我们来分析一下这段代码， 代码功能：划分数据集1234567891011def splitDataSet(dataSet,axis,value): #传入三个参数第一个参数是我们的数据集，是一个链表形式的数据集；第二个参数是我们的要依据某个特征来划分数据集retDataSet = [] #由于参数的链表 dataSet 我们拿到的是它的地址，也就是引用，直接在链表上操作会改变它的数值，所以我们新建一格链表来做操作for featVec in dataSet: if featVec[axis] == value: #如果某个特征和我们指定的特征值相等 #除去这个特征然后创建一个子特征 reduceFeatVec = featVec[:axis] reduceFeatVec.extend(featVec[axis+1:]) #将满足条件的样本并且经过切割后的样本都加入到我们新建立的样本中 retDataSet.append(reduceFeatVec)return retDataSet 12345678910111213总的来说，这段代码的功能就是按照某个特征的取值来划分数据集。 为方便您测试实验我们在贴出这段代码： 1234567891011def splitDataSet(dataSet,axis,value): retDataSet = [] for featVec in dataSet: if featVec[axis] == value: reduceFeatVec = featVec[:axis] reduceFeatVec.extend(featVec[axis+1:]) retDataSet.append(reduceFeatVec)return retDataSet#在这里我们可以注意到一个关于链表的操作：#那就是extend 和append 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126import numpy as npimport pandas as pdfrom math import *#构建数据集def createDataset(): dataSet = [[1, 1, 'yes'], [1, 1, 'yes'], [1, 0, 'no'], [0, 1, 'no'], [0, 1, 'no']] labels = ['no surfacing', 'flippers','is fish'] w1 = pd.DataFrame(dataSet,columns = labels) display(w1) return dataSet, labelscreateDataset()def calcShannoEnt(dataset): allnums = len(dataset) labels = {} for data in dataset: datalabel = data[-1] #初始化所有标签 if datalabel not in labels: labels[datalabel] = 0 labels[datalabel] += 1 hx = 0.0 for key in labels: #计算每种决策的概率 px = float(labels[key]/allnums) hx -= px * log(px,2) print(&quot;hx:&quot;,hx); #计算墒 return hxcalcShannoEnt(createDataset()[0])def splitDataSet(dataSet, index, value): retDataSet = [] for featVec in dataSet: # index列为value的数据集【该数据集需要排除index列】 # 判断index列的值是否为value if featVec[index] == value: # reducedFeatVec = featVec[:index] reducedFeatVec.extend(featVec[index+1:]) # [index+1:]表示从跳过 index 的 index+1行，取接下来的数据 # 收集结果值 index列为value的行【该行需要排除index列】 retDataSet.append(reducedFeatVec) #print(retDataSet) return retDataSetsplitDataSet(createDataset()[0],1,1)def chooseBestFeatureToSplit(dataSet): #需要进行多少次判断特征值 nums = len(dataSet[0]) - 1 baseEnt = calcShannoEnt(dataSet) bestInfoGain, bestFeature = 0.0, -1 for i in range(nums): #找出第一个特征值可能取得的值 featList = [example[i] for example in dataSet] print(&quot;featList:&quot;,featList) #将取得的值离散化 取出唯一值 uniqueList = set(featList) print(&quot;uniqueList&quot;,uniqueList) newE = 0.0 for j in uniqueList: #取出划分出来的子集 subDataset = splitDataSet(dataSet,i,j) print(&quot;subDataset:&quot;,subDataset) # 计算概率 prob = len(subDataset)/float(len(dataSet)) # 计算数学期望 newE += prob * calcShannoEnt(subDataset) #计算出信息增益 infoGain = baseEnt - newE print(f&quot;信息增益:{infoGain},特征值:{i}&quot;) if infoGain &gt; bestInfoGain: bestFeature = i bestInfoGain = infoGain #返回最优特征值 return bestFeaturechooseBestFeatureToSplit(createDataset()[0])def createTree(dataSet,labels): classList = [x[-1] for x in dataSet] #如果所有的标签都相同 就返回一个 if classList.count(classList[0]) == len(classList): return classList[0] #如果只有一列 则表明只有一类 if len(dataSet[0]) == 1: return majorityCnt(classList) bestFeat = chooseBestFeatureToSplit(dataSet) bestFeatLabel = labels[bestFeat] #创建决策树 myTree = {bestFeatLabel:{}} #删除同名变量 del(labels[bestFeat]) #选择最优列 作为分类依据 featValues = [x[bestFeat] for x in dataSet] uniqueVals = set(featValues) for i in uniqueVals: #拷贝一个标签labels副本 subLabels = labels[:] myTree[bestFeatLabel][i] = createTree(splitDataSet(dataSet,bestFeat,i),subLabels) return myTreea,b = createDataset()createTree(a,b)def test(moudelTree,featLabels,testVec): index = featLabels.index(list(moudelTree.keys())[0]) key = featLabels[index] val = testVec[index] print(f&quot;key:{key},val:{val}&quot;) newTree = moudelTree[key][val] print(newTree) if isinstance(newTree,dict): test(newTree,featLabels,testVec) else: return vala,b = createDataset()test(createTree(a,b),['no surfacing', 'flippers'],(1,1))","link":"/2021/10/03/%E5%86%B3%E7%AD%96%E6%A0%91/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/09/10/hello-world/"},{"title":"【实战】某习通app逆向分析（一）检测切屏、拍照、上传","text":"前言Android 上的应用安装文件是 apk 格式，这个 apk 文件其实就是个归档文件压缩包，把应用相关的源码、资源文件、配置文件等乱七八糟的东西都简单粗暴的归档打包，其包内文件结构大体如下： 文件或目录 作用 META-INF/ 存放签名信息，用来保证 apk 包的完整性和系统的安全。 res/ 存放资源文件的目录 libs/ 若存在，则存放的是 ndk 编译出来的 so 文件库 AndroidManifest.xml 程序全局配置文件 classes.dex 最终生成的 dalvik 字节码 resources.ars 编译后的二进制资源文件。通常本地化、汉化资源存储在该文件文件中。 因此，我们将 apk 后缀改成 zip 压缩格式并直接解压就能得到 app 的 dalvik 指令集 dex 文件，然后再将其反编译为 smali 文件，还可以再反编译为 java 代码文件，这样就几乎等同于拿到了 app 就能拿到可读性还蛮清晰的源码，导致逆向破解的门槛几乎很低；没有做防范措施的 app 几乎等同于在裸奔，因此后来演变出来一些保护措施，让 apk 被反编译后获取的代码难理解。 准备阶段查壳 发现是某梆加固，但是 pkid 查壳有不确定性，打开 apk -&gt; lib 发现了特征 DexHelper 确定了加固 脱壳在这里不再进行二代壳脱壳讲解，这里有个小技巧，把这些 dex 文件重命名为 classes.dex、classes1.dex、…, 然后压缩成 zip，把后缀改为 apk。再用 jadx 打开这个 apk，就能一次载入所有的 dex 文件了。(或者使用 jadx 1.2，这个版本可以打开多个 dex 文件，我也是后来才发现) 但是前提是要将他们进行 dex 修复后才可以打包 开始对于安卓来说，检测用户切屏无非就是两个权限 获取手机某个权限（例如：悬浮窗） root对于第二条来说 root 基本是不可能的，所以我们的中心是第一条 分析我们知道学习通在考试的时候会检测切屏 悬浮窗 复制粘贴 人脸拍照等等，在上网查相关资料时候发现 在 2020 年时候检测切屏会发一个请求 当我搜索关键字”离开“的时候 只搜索到了 用户状态 = ？ 离开会议 所以没有继续深入研究下去 问题来了：app 如何检测用户的呢？ 带着这个疑惑 我们去百度查一下开发 API 发现好像并没有什么用 带着这个问题 进入到 app 内部进行分析 打开脱壳后的 app 发现 app 并没有做什么混淆 所以我们找到 exam 这个包点进去看 发现了一个内部类 关键函数出来了 onDown onScroll onSingleTapUp 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class C4515b extends GestureDetector.SimpleOnGestureListener { /* renamed from: c */ public int f14877c; /* renamed from: d */ public int f14878d; public C4515b() { } @Override // android.view.GestureDetector.SimpleOnGestureListener, android.view.GestureDetector.OnGestureListener public boolean onDown(MotionEvent motionEvent) { int[] iArr = new int[2]; ExamFaceWindow.this.f14867d.getLocationOnScreen(iArr); this.f14877c = iArr[0]; this.f14878d = iArr[1]; return super.onDown(motionEvent); } @Override // android.view.GestureDetector.SimpleOnGestureListener, android.view.GestureDetector.OnGestureListener public boolean onScroll(MotionEvent motionEvent, MotionEvent motionEvent2, float f, float f2) { float rawX = motionEvent2.getRawX() - motionEvent.getRawX(); float rawY = motionEvent2.getRawY() - motionEvent.getRawY(); WindowManager.LayoutParams layoutParams = (WindowManager.LayoutParams) ExamFaceWindow.this.f14867d.getLayoutParams(); int i = (int) (this.f14877c + rawX); int i2 = (int) (this.f14878d + rawY); FloatViewLocation.m25890a(i); FloatViewLocation.m25888b(i2); layoutParams.x = i; layoutParams.y = i2; ExamFaceWindow.this.f14866c.updateViewLayout(ExamFaceWindow.this.f14867d, layoutParams); return super.onScroll(motionEvent, motionEvent2, f, f2); } @Override // android.view.GestureDetector.SimpleOnGestureListener, android.view.GestureDetector.OnGestureListener public boolean onSingleTapUp(MotionEvent motionEvent) { if (ExamFaceWindow.this.f14875l != null) { ExamFaceWindow.this.f14875l.m103234a(); return true; } return true; }} 所以目前来说 我们只需要去 hook 干掉这三个检测的函数就可以实现屏蔽检测切屏这个功能了 但是我们怎么知道他什么时候拍照了 怎么拍照的呢？那是不是得有一个状态 Status，所以进行了进一步搜索与跟进 当我在查看 FaceCollectManager 这个包的时候，发现了一串新的代码 123456789101112public void mo20960a(String str) { if (FaceCollectManager.this.m103256s()) { return; } this. CollectData.setLocalPath(str); this. CollectData.setCollectStatus(1); this. CollectData.setUploadStatus(0); this.f CollectData.setCompleteTime(System.currentTimeMillis()); FaceCollectManager.this.m103280g(); FaceCollectManager.this.m103297a(this.f14859a); } 看到了这个 setUploadStatus 方法，既然有上传状态设置，那必然有上传这个函数或者类，有了这个思路我们去搜索，果然发现了 ExamUploader 这个上传类里包含了这个方法 跟进这个方法看到 1234567public void m25900a(String str) { Map&lt;String, List&lt;CollectData&gt;&gt; map = this.f93983b; if (map == null || map.isEmpty() || !Checkman.m45768d(this.f93985d)) { return; } m25898a(this.f93985d, str, this.f93983b.get(this.f93985d));} 发现了这个类，由于现在的环境属于静态调试，所以无法进行 hook 和动态调试查看里面的内容，但是根据代码来说，这个 m25900a 应该就是上传的关键函数。 总结由于环境问题，无法进行动态调试与分析，所有的调试过程均处于静态调试，所以各位也不要以身犯险，文章仅用于学习参考，切勿用于非法途径。 我自己也是逆向新人，也看过一些针对新人的逆向教程，常因教程不详细而产生过许多疑惑。本篇文章已尽可能地详细，但因精力有限，难免有照顾不到的地方。希望本篇文章能给读者有所启发， 参考文章 https://zhuanlan.zhihu.com/p/143704706?ivk_sa=1024320u https://developer.android.com/guide/topics/media/camera?hl=zh-cn#capture-video https://zhuanlan.zhihu.com/p/143210581 https://sentrylab.cn/blog/2022/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91-%E8%84%B1%E5%A3%B3%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","link":"/2022/06/15/%E3%80%90%E5%AE%9E%E6%88%98%E3%80%91%E6%9F%90%E4%B9%A0%E9%80%9Aapp%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%E6%A3%80%E6%B5%8B%E5%88%87%E5%B1%8F%E3%80%81%E6%8B%8D%E7%85%A7%E3%80%81%E4%B8%8A%E4%BC%A0/"},{"title":"k-NearestNeighbor","text":"KNN 近邻算法的初次实现和做法KNN 概述k-近邻（kNN, k-NearestNeighbor）算法是一种基本分类与回归方法，我们这里只讨论分类问题中的 k-近邻算法。 一句话总结: 近朱者赤近墨者黑！ k 近邻算法实际上利用训练数据集对特征向量空间进行划分，并作为其分类的“模型”。 k 值的选择、距离度量以及分类决策规则是 k 近邻算法的三个基本要素。 KNN 场景电影可以按照题材分类，那么如何区分 动作片 和 爱情片 呢？ 动作片: 打斗次数更多 爱情片: 亲吻次数更多 基于电影中的亲吻、打斗出现的次数，使用 k-近邻算法构造程序，就可以自动划分电影的题材类型。 KNN 原理KNN 工作原理 假设有一个带有标签的样本数据集（训练样本集），其中包含每条数据与所属分类的对应关系。 输入没有标签的新数据后，将新数据的每个特征与样本集中数据对应的特征进行比较。 计算新数据与样本数据集中每条数据的距离。 对求得的所有距离进行排序（从小到大，越小表示越相似）。 取前 k （k 一般小于等于 20 ）个样本数据对应的分类标签。 求 k 个数据中出现次数最多的分类标签作为新数据的分类。 KNN 通俗理解给定一个训练数据集，对新的输入实例，在训练数据集中找到与该实例最邻近的 k 个实例，这 k 个实例的多数属于某个类，就把该输入实例分为这个类。 KNN 算法的特点123优点: 精度高、对异常值不敏感、无数据输入假定缺点: 计算复杂度高、空间复杂度高适用数据范围: 数值型和标称型 KNN 算法初次实验123456789101112131415161718192021222324252627282930313233343536373839404142434445from numpy import *import operatorfrom os import listdirfrom collections import Counter#导入必要模块def createDataSet(): #创建数据集和标签 group = array([[1.0, 1.1], [1.0, 1.0], [0, 0], [0, 0.1]]) labels = ['A', 'A', 'B', 'B'] return group,labelsdef classify0(inX,dataSet,labels,k): #获取源数据矩阵的大小 dataSetSize = dataSet.shape[0] print(dataSetSize) print(tile(inX,(dataSetSize,1))) #生成矩阵差的值 diffMat = tile(inX,(dataSetSize,1)) - dataSet #取平方 sqDiffMat = diffMat ** 2 #对每一行都求和 sqDistances = sqDiffMat.sum(axis = 1) #对求和进行根号 distances = sqDistances ** 0.5 #根据距离进行排序从小到大进行排序，并且返回排序后的index sortedDisINdicies = distances.argsort() classCount = {} for i in range(k): #获取该元素的标签是什么 voteIlabel = labels[sortedDisINdicies[i]] #每出现一次，将这个标签+1 classCount[voteIlabel] = classCount.get(voteIlabel, 0) + 1 # 利用max函数直接返回字典中value最大的key maxClassCount = max(classCount,key = classCount.get) # 返回类型 return maxClassCountdef test1(): group,labels = createDataSet() display(group) display(labels) print(classify0([0.1,0.1],group,labels,3))test1() 部分文章出自https://github.com/apachecn/AiLearning/blob/master/docs/ml/2.md","link":"/2021/09/26/k-NearestNeighbor/"},{"title":"【实战】人人直播 password 加密分析","text":"分析搜索 passwordjadx 搜索 “password” 找到地点 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950private void aCv() { SettingManager.bmC().m16156rl(&quot;&quot;); SettingManager.bmC().m16124tV(-1); RSA.init(); aBB(); Variables.account = this.fgV.getText().toString().trim(); Variables.password = this.fgU.getText().toString().trim(); if (Variables.account == null || Variables.account.length() == 0) { Toast.makeText(getActivity(), RenrenApplication.getContext().getResources().getString(C4591R.C4595string.v5_0_1_guide_register_account_no_null), 1).show(); } else if (Variables.password == null || Variables.password.length() == 0) { Toast.makeText(getActivity(), RenrenApplication.getContext().getResources().getString(C4591R.C4595string.v5_0_1_guide_register_password_no_null), 1).show(); } else if (Methods.m13910tM(Variables.account)) { Methods.showToast((CharSequence) getResources().getString(C4591R.C4595string.v5_0_1_guide_register_not_have_china), false); } else if (Methods.m13910tM(Variables.password)) { Methods.showToast((CharSequence) getResources().getString(C4591R.C4595string.v5_0_1_guide_register_pwd_have_china), false); } else { deY = RSA.bNv(); this.f14991n = RSA.bNx(); this.f14990e = RSA.bNw(); if (deY != null) { try { Variables.password = RSA.m10340P(Variables.password, this.f14991n, this.f14990e); RSA.kJi = 1; } catch (Exception e) { e.printStackTrace(); } } else { Variables.password = Md5.toMD5(Variables.password); RSA.kJi = 2; } if (Variables.account == null || Variables.account.length() &lt;= 0 || Variables.password == null || Variables.password.length() &lt;= 0) { return; } if (this.fha == null) { try { this.fha = new Dialog(getActivity()); this.fha.setContentView(C4591R.layout.login_dialog); ((ImageView) this.fha.findViewById(C4591R.C4593id.image)).startAnimation(AnimationUtils.loadAnimation(getActivity(), C4591R.anim.login_dialog_scale)); } catch (Exception unused) { } } this.fha.show(); if (RSA.kJi != 1) { deY = null; } C12919ServiceProvider.m_RSA_login(Variables.account, Variables.password, 1, &quot;&quot;, deY, getActivity(), this.dfg); } } firda hook 和 objections hookhook password MD5 123456789101112Java.perform(function () { var MainActivity = Java.use('com.renren.mobile.utils.Md5') MainActivity.toMD5.implementation = function (arg1) { send('Hook Start...') send('=====================arg1=============') send(arg1) var t = this.toMD5(arg1) send('=====================return=============') send(t) return t }}) hook password RSA 1234567891011121314Java.perform(function () { var MainActivity = Java.use('com.renren.mobile.utils.RSA') MainActivity.P.implementation = function (a, b, c) { send('Hook Start...') send('=====================arg1=============') send(a) send(b) send(c) var t = this.P.apply(this, arguments) send('=====================return=============') send(t) return t }}) 12345678[*] Hook Start Running[*] Hook Start...[*] =====================arg1=============[*] a12345678[*] 9ddcf8c2fea9cdf39ab64ca208a99a13e6a607edaf1250ba105a150bc197fc09[*] 10001[*] =====================return=============[*] 9cdbd2bb1c45dff85eaecf20814911c15e1f1c2a6f1bd2f9bb5c5d06b6338fef","link":"/2022/06/13/%E3%80%90%E5%AE%9E%E6%88%98%E3%80%91%E4%BA%BA%E4%BA%BA%E7%9B%B4%E6%92%AD-password/"},{"title":"安卓逆向学习之RSA加密算法","text":"RAS 算法简介它是又罗纳德.李维斯特、阿迪.萨莫尔和伦纳德.阿德曼在 1977 年提出，当时他们三人在麻省理工学院工作，RSA 就是他们三大姓开头字母拼在一起组成的。 RSA 是最流行的非对称加密算法之一，也被称之为公钥加密。 特点最流行的非对称加密算法之一（也就是说用来加密的密钥和用来解密的密钥不是同一个），和 DES 一样的，RSA 也是分组加密算法，不同的是分组大小可以根据密钥的大小可以根据密钥的大小而改变，如果加密的数据不是分组大小的整数倍，那么根据具体的应用方式增加额外的填充位。RSA 作为一种非对称的加密算法，其中很重要的一个特点就是，当数据在网络中传输时，用来加密数据的密钥并不需要和数据一起传送，因此这就减少了密钥泄露的可能性。 RSA 在不允许加密的时候也是非常有用的。加密的一方使用一个密钥，称为公钥，解密的一方使用另一个密钥，称为私钥，私钥需要保持其私有性。 RSA 被认为是非常安全的，不过其计算速度要比 DES 慢的多，同 DES 一样其安全性也从未被证明过。（要想攻破 RSA 算法涉及的大数的因子分解是一个极其困难的问题，由于缺乏解决大数因子分解的有效方法，因此可以推断出，目前没有有效的办法可以破解RSA） RSA 算法原理从基本上来说加密和解密数据都是围绕着模幂运算，这是取模计算中的一种，取模计算是整数计算中的一种常见形式。如：40mod 13=1 因为 40/13=3，而余数为 1 模幂运算就是计算 ab mod n 的过程 $$a \\cdot b \\div n$$ 在 eclipse 中分析 RSA 算法的代码我们在 eclipse 中已经准备好这个工程，我们直接在 mainactivity 分析这几个重要的方法。 过程第一个是一个私钥加密，然后是一个公钥解密，然后是应该公钥加密，又是一个私钥解密。 我们去 RSA 中去分析一下这几种方法，我们从上往下看。 encrypt首先是密钥长度的定义 然后是一个初始化密钥，我们去看一下这个逻辑，首先我们实例化密钥生成，然后初始化密钥生成器，紧接着生成密钥对，分别是公钥，私钥然后将密钥对存储在 map 中。 接下来我们取的私钥 然后取的公钥 然后对私钥进行加密 这里我们首先要取的私钥，对私钥进行一个处理，紧接着对数据进行一个加密，在网下是一个公钥加密。 decrypt跟上面一样我们首先取的公钥，然后对公钥进行一个处理，生成一个公钥对象，然后进行一个操作。 在往下是一个公钥加密。 一个私钥解密。 这个逻辑其实方法里面都差不多，我们最主要重点关注的是下面这几个方法。 分析 RSA 类 1234567generateKeyPair：生成密钥对getPublic：获取公钥getPrivate：获取私钥PKCS8EncodedKeySpec：根据定制的编码密钥创建一个新的PKCS8EncodedKeySpecKeyFactory：密钥工厂用于将密钥（Key类型的不透明加密密钥）转换成密钥规范（底层密钥材料的透明表示）generarePublic：根据提供的密钥规范（密钥材料）生成公钥对象","link":"/2022/06/13/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0%E4%B9%8BRSA%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"title":"堆排序","text":"堆分为小根堆和大根堆（本质上是一颗完全二叉树） 堆可以干什么？ 找到一个集合当中的最小值 删除一个集合当中的最小值 插入一个数 如何调整小根堆或者大根堆？以小根堆为例子 down -&gt; 选择这个数和子节点的最小值进行交换 up -&gt; 选择这个节点与父节点进行交换 如何存储堆？下标从 1 开始 保证了数组子节点的可行性 选择用数组的形式来存储 1 2 3 4 5 6 7 8k 的 子节点为 2k 2k+1 如何手写一个堆 插入一个数：heap[++size] = x; 求集合当中的最小元素：heap[1]; 删除最小的元素：heap[1] = heap[size]; size ++; down(1) //将末尾的元素覆盖到头节点，数组删除头节点是很麻烦的一件事 删除任意一个元素：heap[k] = heap[size]; size ++; down(k); up(k)； 修改任意一个元素：heap[k] = x;up(x);down(x); 保证 down 和 up 只执行一次 模版题838. 堆排序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.util.*;import java.io.*;public class Main{ public static int size = 0; public static int h[]; public static void main(String[] args) throws IOException{ Scanner in = new Scanner(new BufferedInputStream(System.in)); BufferedWriter log = new BufferedWriter(new OutputStreamWriter(System.out)); int n = in.nextInt(); int m = in.nextInt(); size = n; h = new int[n + 1]; for(int i = 1 ; i &lt;= n ; i ++){ h[i] = in.nextInt(); } //初始化小根堆 优化时间复杂度：nlogn -&gt; n for(int i = n/2 ; i != 0 ; i --){ down(i); } while(m -- != 0){ log.write(h[1] + &quot; &quot;); //删除最小值 h[1] = h[size]; size --; down(1); } log.flush(); log.close(); in.close(); } //向下调整小根堆 public static void down(int u){ int t = u; //用t来存储最小值的编号 if(u*2 &lt;= size &amp;&amp; h[u*2] &lt; h[t]) t = u * 2; if(u*2+1 &lt;= size &amp;&amp; h[u*2+1] &lt; h[t]) t = u * 2 + 1; if(t != u){ int c = h[t]; h[t] = h[u]; h[u] = c; down(t); //递归调整最小值 } } //向上调整小根堆 public static void up(int u){ while(u/2 != 0 &amp;&amp; h[u] &lt; h[u / 2]){ int c = h[u]; h[u] = h[u/2]; h[u/2] = c; u /= 2; } }} 839. 模拟堆 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import java.util.*;import java.io.*;class Main{ static BufferedReader read = new BufferedReader(new InputStreamReader(System.in)); static BufferedWriter log = new BufferedWriter(new OutputStreamWriter(System.out)); static int[] h; static int[] ph; //存放第k个插入点的下标 static int[] hp; //存放堆中点的插入次序 static int size; public static void main(String[] args) throws Exception{ int n = Integer.valueOf(read.readLine()); h = new int[n + 1]; ph = new int[n + 1]; hp = new int[n + 1]; size = 0; int m=0; //m用来记录插入的数的个数 while(n-- &gt; 0){ String[] s = read.readLine().split(&quot; &quot;); String op = s[0]; if(&quot;I&quot;.equals(op)){ int x = Integer.valueOf(s[1]); m++; h[++size]=x; ph[m]=size; hp[size]=m; //down(size); up(size); }else if(&quot;PM&quot;.equals(op)) log.write(h[1] + &quot;\\n&quot;); else if(&quot;DM&quot;.equals(op)){ heapSwap(1,size); size--; down(1); }else if(&quot;D&quot;.equals(op)){ int k = Integer.valueOf(s[1]); int u=ph[k]; //这里一定要用u=ph[k]保存第k个插入点的下标 heapSwap(u,size); //因为在此处heapSwap操作后ph[k]的值已经发生 size--; //如果在up,down操作中仍然使用ph[k]作为参数就会发生错误 up(u); down(u); }else if(&quot;C&quot;.equals(op)){ int k = Integer.valueOf(s[1]); int x = Integer.valueOf(s[2]); h[ph[k]]=x; //此处由于未涉及heapSwap操作且下面的up、down操作只会发生一个所以 down(ph[k]); //所以可直接传入ph[k]作为参数 up(ph[k]); } } log.flush(); } //这个交换过程其实有那么些绕 但关键是理解 如果hp[u]=k 则ph[k]=u 的映射关系 //之所以要进行这样的操作是因为 经过一系列操作 堆中的元素并不会保持原有的插入顺序 //从而我们需要对应到原先第K个堆中元素 //如果理解这个原理 那么就能明白其实三步交换的顺序是可以互换 //h,hp,ph之间两两存在映射关系 所以交换顺序的不同对结果并不会产生影响 public static void heapSwap(int u, int v){ swap(h,u,v); swap(hp, u, v); swap(ph, hp[u], hp[v]); } public static void swap(int[] a, int u, int v){ int tmp = a[u]; a[u] = a[v]; a[v] = tmp; } public static void down(int u){ int t = u; if(u * 2 &lt;= size &amp;&amp; h[t] &gt; h[u * 2]) t = u * 2; if(u * 2 + 1 &lt;= size &amp;&amp; h[t] &gt; h[u * 2 + 1]) t = u * 2 + 1; if(u != t){ heapSwap(u, t); down(t); } } public static void up(int u){ if(u / 2 &gt; 0 &amp;&amp; h[u] &lt; h[u / 2]){ heapSwap(u, u / 2); up(u/2); } }}","link":"/2021/09/11/%E5%A0%86%E6%8E%92%E5%BA%8F/"},{"title":"哈希表","text":"近似 O(1)的时间复杂度 哈希表一般算法中处理的问题 插入一个数 查找一个数 删除一个数 实现哈希表的两种做法拉链法首先选择拉链法来解决问题，拉链法用通俗的话来说，就是数组+单链表的实现选择 hash 函数 将大整数 x 映射成为小整数的 840. 模拟散列表 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 100002;int e[N],ne[N],idx;int h[N];void insert(int x){ int y = (x % N + N) % N; //为了缩小y 同时也避免负数的存在 e[idx] = x; //在每一个数组下面拉出一条链 insert等同于单链表的操作 ne[idx] = h[y]; h[y] = idx++;}bool find(int x){ int y = (x % N + N ) % N; for(int i = h[y] ; i != -1 ; i = ne[i]) if(e[i] == x) return true; return false;}int main(){ int n; cin &gt;&gt; n; memset(h,-1,sizeof h); while(n --){ char op; int k; cin &gt;&gt; op &gt;&gt; k; if(op == 'I')insert(k); else{ if(find(k))puts(&quot;Yes&quot;); else puts(&quot;No&quot;); } } return 0;} 开放寻址法开放寻址法本质也是从前往后插入，比拉链法更简单的是它只需要开一个数组，操作和理解起来相对容易一点。开放寻址法从前往后找找到空的地方插入，如果已经有了就让当前这个位置的加一 840. 模拟散列表 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 200003,null = 0x3f3f3f3f;int h[N];int find(int x){ int t = (x % N + N)%N; while(h[t] != null &amp;&amp; h[t] != x){ t ++; if(t == N)t = 0; } return t;}int main(){ int n; cin &gt;&gt; n; memset(h,0x3f,sizeof h); while(n --){ char op; int x; cin &gt;&gt; op &gt;&gt; x; int k = find(x); if(op == 'I'){ h[k] = x; }else{ if(h[k] == null)puts(&quot;No&quot;); else puts(&quot;Yes&quot;); } } return 0;} 字符串哈希(字符串哈希) O(n)+O(m) 全称字符串前缀哈希法，把字符串变成一个 p 进制数字（哈希值），实现不同的字符串映射到不同的数字。对形如 X1X2X3⋯Xn−1Xn的字符串,采用字符的 ascii 码乘上 P 的次方来计算哈希值。 映射公式 (X1×Pn−1+X2×Pn−2+⋯+Xn−1×P1+Xn×P0)modQ 注意点： 任意字符不可以映射成 0，否则会出现不同的字符串都映射成 0 的情况，比如 A,AA,AAA 皆为 0 冲突问题：通过巧妙设置 P (131 或 13331) , Q (264)的值，一般可以理解为不产生冲突。 问题是比较不同区间的子串是否相同，就转化为对应的哈希值是否相同。求一个字符串的哈希值就相当于求前缀和，求一个字符串的子串哈希值就相当于求部分和。 前缀和公式 h[i+1]=h[i]×P+s[i]i∈[0,n−1]h 为前缀和数组，s 为字符串数组区间和公式 h[l,r]=h[r]−h[l−1]×Pr−l+1 区间和公式的理解: ABCDE 与 ABC 的前三个字符值是一样，只差两位，乘上 P2把 ABC 变为 ABC00，再用 ABCDE - ABC00 得到 DE 的哈希值。 作者：chocolate-emperor链接：https://www.acwing.com/solution/content/24738/来源：AcWing著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 841. 字符串哈希 123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;typedef unsigned long long ULL;const int N = 100010,P = 131;ULL p[N],h[N];ULL get(int l,int r){ return h[r] - h[l-1]*p[r-l+1];}int main(){ int n,m; string str; cin &gt;&gt; n &gt;&gt; m &gt;&gt; str; p[0] = 1; h[0] = 0; for(int i = 1 ; i &lt;= n ; i ++){ p[i] = p[i-1] * P; h[i] = h[i-1] * P + str[i - 1]; } while(m -- != 0){ int l1,r1,l2,r2; cin &gt;&gt; l1 &gt;&gt; r1 &gt;&gt; l2 &gt;&gt; r2; if(get(l1,r1) != get(l2,r2))puts(&quot;No&quot;); else puts(&quot;Yes&quot;); } return 0;}","link":"/2021/09/20/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"title":"安卓逆向学习之objection基础用法","text":"0x1 介绍&amp;安装 Objectionobjection 是基于 frida 的命令行 hook 工具, 可以让你不写代码, 敲几句命令就可以对 java 函数的高颗粒度 hook, 还支持 RPC 调用 目前只支持 Java 层的 hook, 但是 objection 有提供插件接口, 可以自己写 frida 脚本去定义接口 比如葫芦娃大佬的脱壳插件, 实名推荐: FRIDA-DEXDump 官方仓库: objection 安装前置条件 121. python版本 &gt; 3.42. pip版本 &gt; 9.0 安装命令 1pip3 install objection 安装完成后, 直接输入objection, 就可以看到食用方法了 123456789101112131415161718192021222324252627282930313233343536Usage: objection [OPTIONS] COMMAND [ARGS]... _ _ _ _ ___| |_|_|___ ___| |_|_|___ ___ | . | . | | -_| _| _| | . | | |___|___| |___|___|_| |_|___|_|_| |___|(object)inject(ion) Runtime Mobile Exploration by: @leonjza from @sensepost By default, communications will happen over USB, unless the --network option is provided.Options: -N, --network Connect using a network connection instead of USB. [default: False] -h, --host TEXT [default: 127.0.0.1] -p, --port INTEGER [default: 27042] -ah, --api-host TEXT [default: 127.0.0.1] -ap, --api-port INTEGER [default: 8888] -g, --gadget TEXT Name of the Frida Gadget/Process to connect to. [default: Gadget] -S, --serial TEXT A device serial to connect to. -d, --debug Enable debug mode with verbose output. (Includes agent source map in stack traces) --help Show this message and exit.Commands: api Start the objection API server in headless... device_type Get information about an attached device. explore Start the objection exploration REPL. patchapk Patch an APK with the frida-gadget.so. patchipa Patch an IPA with the FridaGadget dylib. run Run a single objection command. version Prints the current version and exists. 0x2 简单使用一下 使用前几个使用 tips 1231. 空格键: 忘记命令直接输入空格键, 会有提示与补全2. help: help [command] 会有详细介绍指定命令的作用与例子3. jobs: 任务管理系统, 可以方便的查看与删除任务 启动 Frida-server 并转发端口 附加需要调试的 app, 进入交互界面 1objection -g [packageName] explore 可以使用该 env 命令枚举与所讨论的应用程序相关的其他有趣目录: env 12345678910111213com.opera.mini.native on (samsung: 6.0.1) [usb] # envName Path---------------------- ------------------------------------------------------------filesDirectory /data/user/0/com.opera.mini.native/filescacheDirectory /data/user/0/com.opera.mini.native/cacheexternalCacheDirectory /storage/emulated/0/Android/data/com.opera.mini.native/cachecodeCacheDirectory /data/user/0/com.opera.mini.native/code_cacheobbDir /storage/emulated/0/Android/obb/com.opera.mini.nativepackageCodePath /data/app/com.opera.mini.native-1/base.apk 我们可以使用以下 file download 命令从远程文件系统中下载文件:file download [file] [outfile] 12com.opera.mini.native on (samsung: 6.0.1) [usb] # file download fhash.dat fhash.datDownloading /data/user/0/com.opera.mini.native/cache/fhash.dat to fhash.dat 可以列出 app 具有的所有 avtivity: android hooking list activities 1234567891011com.opera.mini.native on (samsung: 6.0.1) [usb] # android hooking list activitiescom.facebook.ads.AudienceNetworkActivitycom.google.android.gms.ads.AdActivitycom.google.android.gms.auth.api.signin.internal.SignInHubActivitycom.google.android.gms.common.api.GoogleApiActivitycom.opera.android.AssistActivitycom.opera.android.MiniActivitycom.opera.android.ads.AdmobIntentInterceptorcom.opera.mini.android.BrowserFound 8 classes 启动指定 avtivity: android intent launch_activity [class_activity] 12com.opera.mini.native on (samsung: 6.0.1) [usb] # android intent launch_activity com.facebook.ads.AudienceNetworkActivityLaunching Activity: com.facebook.ads.AudienceNetworkActivity... RPC 调用命令: curl -s &quot;http://127.0.0.1:8888/rpc/invoke/androidHookingListActivities&quot; 1234567891011$ curl -s &quot;http://127.0.0.1:8888/rpc/invoke/androidHookingListActivities&quot;[&quot;com.reddit.frontpage.StartActivity&quot;,&quot;com.reddit.frontpage.IntroductionActivity&quot;, ... snip ...]- RPC调用执行脚本:`url -X POST -H &quot;Content-Type: text/javascript&quot; http://127.0.0.1:8888/script/runonce -d &quot;@script.js&quot;`$ cat script.js{ send(Frida.version);}[{&quot;payload&quot;:&quot;12.8.0&quot;,&quot;type&quot;:&quot;send&quot;}] RPC WIKI 0x3 API 介绍 以下只是写了一部分指令和功能, 详细的功能需要合理运用空格和help呦 Memory 指令 1234memory list modules //枚举当前进程模块memory list exports [lib_name] //查看指定模块的导出函数memory list exports libart.so --json /root/libart.json //将结果保存到json文件中memory search --string --offsets-only //搜索内存 android heap 12345678//堆内存中搜索指定类的实例, 可以获取该类的实例idsearch instances search instances com.xx.xx.class//直接调用指定实例下的方法android heap execute [ins_id] [func_name]//自定义frida脚本, 执行实例的方法android heap execute [ins_id] root 12345//尝试关闭app的root检测android root disable//尝试模拟root环境android root simulate ui 12345//截图android ui screenshot [image.png]//设置FLAG_SECURE权限android ui FLAG_SECURE false 内存漫游 1234567891011//列出内存中所有的类android hooking list classes//在内存中所有已加载的类中搜索包含特定关键词的类android hooking search classes [search_name]//在内存中所有已加载的方法中搜索包含特定关键词的方法android hooking search methods [search_name]//直接生成hook代码android hooking generate simple [class_name] hook 方式 12345678910111213 /* hook指定方法, 如果有重载会hook所有重载,如果有疑问可以看 --dump-args : 打印参数 --dump-backtrace : 打印调用栈 --dump-return : 打印返回值 */android hooking watch class_method com.xxx.xxx.methodName --dump-args --dump-backtrace --dump-return//hook指定类, 会打印该类下的所以调用android hooking watch class com.xxx.xxx//设置返回值(只支持bool类型)android hooking set return_value com.xxx.xxx.methodName false Spawn 方式 Hook 1objection -g packageName explore --startup-command '[obejection_command]' activity 和 service 操作 1234567891011//枚举activityandroid hooking list activities//启动activityandroid intent launch_activity [activity_class]//枚举servicesandroid hooking list services//启动servicesandroid intent launch_service [services_class] 任务管理器 12345//查看任务列表jobs list//关闭任务jobs kill [task_id] 关闭 app 的 ssl 校验 1android sslpinning disable 监控系统剪贴板 12//获取Android剪贴板服务上的句柄并每5秒轮询一次用于数据。 如果发现新数据，与之前的调查不同，则该数据将被转储到屏幕上。help android clipboard 执行命令行 1help android shell_exec [command] 转自：http://strivemario.work/archives/8eec80c3.html","link":"/2022/06/15/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0%E4%B9%8Bobjection%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/"},{"title":"安卓逆向学习之Objection-Hook自吐请求抓包与辅助分析","text":"前言证书校验在许多业务非常聚焦比如行业应用、银行、公共交通、游戏等行业，C/S 架构中服务器高度集中，对应用的版本控制非常严格，这时候就会在服务器上部署对 app 内置证书的校验代码。抓包出现如下提示时，我们确定出此 APP 为服务器校验 app 客户端证书 对于此类 APP 抓包而言通常需要完成两项内容： 找到证书密码 安装证书 在这里不进行探讨，今天的目的是使用 Objection 来 hook 进行自吐抓包，绕过证书检测。 OkHttp 介绍OkHttp 是一款优秀的网络请求框架，针对于传输层的一种封装，基于 socket 通信OkHttp 有 2.0 版本和 3.0 的版本，目前常用的是 OkHttp3 准备阶段如果我们要进行 hook 就要明确，android 是如何进行 新建一个 Android 工程 引入 Okhttp 这个库 再 AndroidMainFest.xml 中添加网络权限，并再 Gradle 中引入 okhttp 这个库 打开 MainActivity 编写以下代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package cn.mineseb.okhttp;import androidx.appcompat.app.AppCompatActivity;import android.os.Bundle;import android.util.Log;import android.view.View;import android.widget.*;import org.json.JSONArray;import org.json.JSONException;import org.json.JSONObject;import java.io.IOException;import okhttp3.OkHttpClient;import okhttp3.Request;import okhttp3.Response;public class MainActivity extends AppCompatActivity { Button button; TextView textView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); button = findViewById(R.id.button2); textView = findViewById(R.id.text); button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { new Thread(new Runnable() { @Override public void run() { //实例化 里面可能会出现异常，需要try catch OkHttpClient client = new OkHttpClient(); //建立一个Request 通过Builder方法.Url里面填的就是json网址.build创建 Request request = new Request.Builder().url(&quot;https://www.httpbin.org/get?a=1&amp;b=2&quot;).build(); try { //Response是okhttp实例化，并且调用Request。执行后返回的结果\\ Log.i(&quot;codecat&quot;,&quot;okhttp start&quot;); Response response = client.newCall(request).execute(); String s = response.body().string();//获取到的json数据 Log.i(&quot;codecat&quot;,s); Log.i(&quot;codecat&quot;,&quot;请求成功&quot;); } catch (IOException e) { e.printStackTrace(); } } }).start(); } }); }} 装入手机模拟器 点击 Button 查看 Log 成功发送 objection 进行 hook我们知道 Objection 很强大，可以 hook 参数 返回值 调用栈，知道这一点我们就可以进行下一步，具体的使用方法可以看我之前的一篇博客 123android hooking list classescd ~/.objectioncat objection.log|grep okhttp 复制粘贴 一键 hook 发现关键方法 cn.mineseb.okhttp.MainActivity$1.onClick 进行 hook 查看到了栈、发送、返回值。 既然我们明白了原理，我们就可以使用框架 OkhttpLogger 进行一键 hook，同时这个框架也有一键反混淆。 修改 okhttp_poker 文件 再次进行 frida hook hook 成功 12345678910111213141516171819202122232425262728293031323334353637383940414243444546[Pixel 3::cn.mineseb.okhttp ]-&gt; ........... hookRealCall : okhttp3.internal.connection.RealCall┌────────────────────────────────────────────────────────────────────────────────────────────────────────────────────| URL: https://www.httpbin.org/get?a=1&amp;b=2|| Method: GET|| Request Headers: 0| no headers||--&gt; END|| URL: https://www.httpbin.org/get?a=1&amp;b=2|| Status Code: 200 /|| Response Headers: 6| ┌─date: Thu, 16 Jun 2022 07:18:42 GMT| ┌─content-type: application/json| ┌─content-length: 314| ┌─server: gunicorn/19.9.0| ┌─access-control-allow-origin: *| └─access-control-allow-credentials: true|| Response Body:| { &quot;args&quot;: { &quot;a&quot;: &quot;1&quot;, &quot;b&quot;: &quot;2&quot; }, &quot;headers&quot;: { &quot;Accept-Encoding&quot;: &quot;gzip&quot;, &quot;Host&quot;: &quot;www.httpbin.org&quot;, &quot;User-Agent&quot;: &quot;okht| tp/4.4.0&quot;, &quot;X-Amzn-Trace-Id&quot;: &quot;Root=1-62aad952-07cf18fe440c9c816716c120&quot; }, &quot;url&quot;: &quot;https://www.httpbin.org/g| et?a=1&amp;b=2&quot;}||&lt;-- END HTTP└──────────────────────────────────────────────────────────────────────────────────────────────────────────────────── 总结至此，介绍完了关于使用 Hook 抓包的通用流程。从这个案例分析可以发现，通过过滤网络框架的关键字的批量 hook 对快速定位 App 中收发数据包函数的帮助是非常巨大的，而这也正是不适用抓包工具而使用 hook 方式最大的原因。","link":"/2022/06/16/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0%E4%B9%8BObjection-Hook%E8%87%AA%E5%90%90%E8%AF%B7%E6%B1%82%E6%8A%93%E5%8C%85%E4%B8%8E%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90/"},{"title":"排序算法","text":"三种排序[选择，归并，冒泡]选择排序优点：处理小数据的时候很快，时间复杂度(O^2) 选择排序就跟扑克牌一样，从牌堆里面选择一张牌插入到牌中，依次选择手中的牌，把相对较小的插入到其中 1234567891011void insertionSort(int arr[]){ for(int i = 0 ; i &lt; 6 ; i ++){ int key = arr[i]; int j = i - 1; while(j &gt;= 0 &amp;&amp; arr[j] &gt; key){ arr[j + 1] = arr[j]; j --; } arr[j + 1] = key; }} 快速排序时间复杂度为 O(nlogn) 12345678910111213void quick_sort(int q[], int l, int r){ if (l &gt;= r) return; int i = l - 1, j = r + 1, x = q[l + r &gt;&gt; 1]; while (i &lt; j) { do i ++ ; while (q[i] &lt; x); do j -- ; while (q[j] &gt; x); if (i &lt; j) swap(q[i], q[j]); } quick_sort(q, l, j), quick_sort(q, j + 1, r);} 归并排序**时间复杂度 O(n log n) ** 123456789101112131415161718192021222324void mergeSort(int arr[], int l, int r){ if (l &gt;= r) return; int mid = (l + r) / 2; mergeSort(arr, l, mid); mergeSort(arr, mid + 1, r); int k = 0, i = l, j = mid + 1; int tmp[r - l + 1]; while (i &lt;= mid &amp;&amp; j &lt;= r) { if (arr[i] &lt; arr[j]) tmp[k++] = arr[i++]; else tmp[k++] = arr[j++]; } while (i &lt;= mid) tmp[k++] = arr[i++]; while (j &lt;= r) tmp[k++] = arr[j++]; for (i = l, j = 0; i &lt;= r; i++, j++) arr[i] = tmp[j];} 快速排序和快速排序都是分治思想","link":"/2021/09/24/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"title":"并查集","text":"近似 O(1)的时间复杂度 并查集能解决什么问题？ 如何合并两个集合 如何两个元素在不在同一个区间内 并查集原理？用一棵树来存储整个集合，树根的编号就是整个集合的编号。每个节点存储它的父节点，p[x]代表它的父节点 衍生出问题 如何判断树根？if(p[x] == x) 如何求 x 的编号？while(p[x] != x) x = p[x] 如何合并两个集合，x 代表第一个集合，y 代表第二个集合？p[x] = y 如何优化？每遍历一次，让这个节点直接指向根节点，即可将时间复杂度优化为 O(1); 模版应用836. 合并集合 1234567891011121314151617181920212223242526272829303132import java.util.*;import java.io.*;public class Main{ private static int p[] = new int[100010]; //声明父节点; public static void main(String [] args) throws IOException { Scanner in = new Scanner(new BufferedInputStream(System.in)); BufferedWriter log = new BufferedWriter(new OutputStreamWriter(System.out)); int n = in.nextInt(); for(int i = 1 ; i &lt;= n ; i ++)p[i] = i; int m = in.nextInt(); while(m -- != 0){ String op = in.next(); if(op.equals(&quot;M&quot;)){ int a = in.nextInt(); int b = in.nextInt(); p[find(a)] = find(b); }else{ int a = in.nextInt(); int b = in.nextInt(); if(find(a) == find(b))log.write(&quot;Yes\\n&quot;); else log.write(&quot;No\\n&quot;); } } log.flush(); log.close(); } //查找x节点的父亲 public static int find(int x){ if(p[x] != x) p[x] = find(p[x]); return p[x]; }} 837. 连通块中点的数量同时维护当前区间内，有多少个数量 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.*;import java.io.*;public class Main{ public static int p[] = new int[100010]; public static int size[] = new int[100010]; public static void main(String[] args) throws IOException { Scanner in = new Scanner(new BufferedInputStream(System.in)); BufferedWriter log = new BufferedWriter(new OutputStreamWriter(System.out)); int n = in.nextInt(); int m = in.nextInt(); for(int i = 1 ; i &lt;= n ; i ++){ p[i] = i; size[i] = 1; } while(m -- != 0){ String op = in.next(); if(op.equals(&quot;C&quot;)){ int a = in.nextInt(); int b = in.nextInt(); if(find(a) == find(b)) continue; size[find(b)] += size[find(a)]; p[find(a)] = b; }else if(op.equals(&quot;Q1&quot;)){ int a = in.nextInt(); int b = in.nextInt(); if(find(a) == find(b))log.write(&quot;Yes\\n&quot;); else log.write(&quot;No\\n&quot;); }else{ int k = in.nextInt(); log.write(size[find(k)] + &quot;\\n&quot;); } } log.flush(); log.close(); } public static int find(int x){ if(p[x] != x)p[x] = find(p[x]); return p[x]; }} 240. 食物链 维护当前集合里面到根节点的距离 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import java.io.*;import java.util.*;public class Main{ public static int[] p,d; //p存储父节点 d存储距离 public static void main(String[] args) throws IOException{ Scanner in = new Scanner(new BufferedInputStream(System.in)); BufferedWriter log = new BufferedWriter(new OutputStreamWriter(System.out)); int n = in.nextInt(); int m = in.nextInt(); p = new int[n + 1]; d = new int[n + 1]; int ans = 0 ; //表示假话的个数 for(int i = 1 ; i &lt;= n ; i ++)p[i] = i; while(m -- != 0){ int op = in.nextInt(); int x = in.nextInt(); int y = in.nextInt(); if(x &gt; n || y &gt; n){ ans += 1; continue; } int px = find(x); int py = find(y); switch (op) { case 1 : { //同一个集合中，表示已确立相互关系 if (px == py) { if ((d[x] - d[y])%3 != 0) { ans++; continue; } } //不同集合中，现在建立相互关系 else { d[px] = d[y] - d[x]; p[px] = py; } break; } case 2 : { //同一个集合中，表示已确立相互关系 if (px == py) { //推导出的关系为 （d[x]-d[y]）%3 == 1 则认为x可以吃y //写成（d[x]-d[y]-1）%3 == 0 可以避免余数是负数的问题 //也可以写成（d[x]-d[y]）%3 +3 == 1 //==正确 -&gt; != 错误 if ((d[x] - d[y] - 1) % 3 != 0) { ans++; continue; } } //不同集合中，现在建立相互关系 else { d[px] = d[y] - d[x] + 1; p[px] = py; } break; } default : System.out.print(&quot;--&quot;); } } log.write(ans + &quot; &quot;); log.flush(); log.close(); } public static int find(int x){ if(x != p[x]){ int u = find(p[x]); d[x] += d[p[x]]; p[x] = u; } return p[x]; }}","link":"/2021/09/10/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"title":"安卓逆向学习之Frida-RPC远程调用与主动调用","text":"准备阶段Android 应用开发 先准备一个工程，编写以下代码 123456789101112131415161718192021222324252627282930313233343536373839package cn.mineseb.rpc;import androidx.appcompat.app.AppCompatActivity;import android.os.Bundle;import android.util.Log;public class MainActivity extends AppCompatActivity { private String total = &quot;codecat&quot;; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); while (true){ try { Thread.sleep(1000); }catch (InterruptedException e){ e.printStackTrace(); } } } void fun(int x,int y){ Log.d(&quot;r0ysue.com&quot;,String.valueOf(x+y)); } String fun(String x){ return x.toLowerCase(); } void secret(){ total += &quot;cool!!!&quot;; Log.d(&quot;secret&quot;,&quot;this is secret func&quot;); } static void staticSecret(){ Log.d(&quot;staticSecret&quot;,&quot;this is static secret func&quot;); }} 将模拟器 adb 链接 studio 并且点击开始按钮后 出现 成功 主动调用 拷贝包名 copy path cn.mineseb.rpc.MainActivity 静态方法静态方法直接调用即可 MainActivity.staticSecret; 但是非静态方法调用不可用.来调用 Java.choose(‘cn.mineseb.rpc.MainActivity’, { 12345678910111213141516171819202122232425function main() { console.log('Script loaded successfully') Java.perform(function () { //静态方法 console.log('Java perform function') var MainActivity = Java.use('cn.mineseb.rpc.MainActivity') MainActivity.staticSecret Java.choose('cn.mineseb.rpc.MainActivity', { onMatch: function (instance) { console.log('instance found', instance) console.log('===========before========') console.log('total &gt;&gt;&gt;&gt; ', instance.total.value) instance.secret() console.log('===========after=========') console.log('total &gt;&gt;&gt;&gt; ', instance.total.value) }, onComplete: function () { console.log('search Complete') }, }) })}setTimeout(main, 2000) RPCRPC 的目的是我们可以通过远程调用 实现自动化 所以我们需要借助 python 来进行通信 如果需要进行实时的话可以加上 WebSocket 进行通信 使用上面提到的 APP Demo 修改 Frida Js 12345678910111213141516171819202122232425262728function callSecretFunc() { Java.perform(function() { Java.choose('cn.mineseb.rpc.MainActivity'. { onMatch: function(instance) { console.log(&quot;=====callSecretFunc======&quot;); instance.secret(); }, onComplete: function() {} }) })}function getTotalValue() { Java.perform(function() { var MainActivity = Java.use(&quot;cn.mineseb.rpc.MainActivity&quot;) Java.choose('cn.mineseb.rpc.MainActivity', { onMatch: function(instance) { console.log(&quot;=====getTotalValue======&quot;); console.log(instance.total.value); }, onComplete: function() { } }) })}setTimeout(getTotalValue, 2000) Frida hook 在 js 脚本后面导出 注意导出名称不可包含大写字母或者下划线 1234rpc.exports = { callsecretsunc: callSecretFunc, gettotalvalue: getTotalValue,} 出现这个错误时候 但是 adb 是连接的 并且手机端 frida 是打开的 说明映射没有开启 adb forward tcp:27042 tcp:27042 提示 选择用 spawn 进行 hook 123456789101112device = frida.get_remote_device()pid = device.spawn([&quot;cn.mineseb.rpc&quot;])session = device.attach(pid)device.resume(pid)with open(&quot;rpc.js&quot;) as f: jscode = f.read()script = session.create_script(jscode)script.on('message', on_message)print('[*] Hook Start Running')script.load() 远程 python 脚本 1234567891011121314151617181920212223242526272829303132import frida, sysdef on_message(message, data): if message['type'] == 'send': print(&quot;[*] {0}&quot;.format(message['payload'])) else: print(message)device = frida.get_remote_device()pid = device.spawn([&quot;cn.mineseb.rpc&quot;])session = device.attach(pid)device.resume(pid)with open(&quot;rpc.js&quot;) as f: jscode = f.read()script = session.create_script(jscode)script.on('message', on_message)print('[*] Hook Start Running')script.load()command = &quot;&quot;while True: command = input(&quot;command = &quot;) if command == &quot;0&quot;: break elif command == &quot;1&quot;: script.exports.callsecretsunc() else: script.exports.gettotalvalue() 总结通过 frida 的主动调用可以实现自吐算法 不用去跟进。将关键算法拿到并且 fridaHook 成功 与 rpc 相结合可以实现远程调用，不用自写算法即可拿到加密后的值，实现自动化","link":"/2022/06/15/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E4%B9%8BFrida-RPC%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E4%B8%8E%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8/"},{"title":"归一化","text":"什么是归一化？以实际例子来说，在国家贸易中，各个国家的货币价值不一样，当 A 国想买 10 吨煤的时候，我们一般是先将钱转化为美元，再用美元去买 10 吨煤，这样中间就有了一个标准 归一化有什么用？归一化在处理数学问题和权重问题的时候具有实用的意义，比如说大学生自习室安排问题中，宿舍距各教室路线长短，教室大小，照明质量，满座率等都是影响结果的因素，这些因素本身有一个相对值，但没有一个统一的标准去衡量他们，于是出现了归一化。使每个大因素和小变量之间都有了一个桥梁，合理的去参与到对决策的影响中。","link":"/2021/09/25/%E5%BD%92%E4%B8%80%E5%8C%96/"},{"title":"【实战】某大学信息门户登录分析","text":"抓包参数分析Cookie 分析通过抓包分析 发现 在访问 1http://authserver.tjut.edu.cn/authserver/login?service=http%3A%2F%2Fehall.tjut.edu.cn%2Flogin%3Fservice%3Dhttp%3A%2F%2Fehall.tjut.edu.cn%2Fnew%2Findex.html 时候 会设置两个 Cookies：route 和 JSESSIONID，当我们清空这两个 cookies 的时候点击登录发现会重定向，确定 ck 是服务器确认登录请求的值。用 python 模拟 12345678910111213141516171819202122head = { &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&quot;, &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.9&quot;, &quot;Cache-Control&quot;: &quot;no-cache&quot;, &quot;Connection&quot;: &quot;keep-alive&quot;, &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;, &quot;Host&quot;: &quot;authserver.tjut.edu.cn&quot;, &quot;Origin&quot;: &quot;http://authserver.tjut.edu.cn&quot;, &quot;Pragma&quot;: &quot;no-cache&quot;, &quot;Upgrade-Insecure-Requests&quot;: &quot;1&quot;, &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.67 Safari/537.36&quot;}#session = requests.session()res = session.get(url = URL[&quot;index&quot;])html = res.textlogger.debug(res.cookies)logger.debug(session.cookies)logger.debug(&quot;=============pause================&quot;) 12022-06-14 15:43:25.215 | DEBUG | __main__:&lt;module&gt;:45 - &lt;RequestsCookieJar[&lt;Cookie JSESSIONID=4ldhKdeMCHs8LqBGsI3fTMNIAHP-IWlG6LlxQz08ZqpYTX2vs-ss!2090879530 for authserver.tjut.edu.cn/&gt;, &lt;Cookie route=476e8ab4730c382ed52d041b4e6f3f90 for authserver.tjut.edu.cn/&gt;]&gt; 分析比较和我们浏览器抓的值一样 登录包分析1234567891011url = http://authserver.tjut.edu.cn/authserver/login?service=http%3A%2F%2Fehall.tjut.edu.cn%2Flogin%3Fservice%3Dhttp%3A%2F%2Fehall.tjut.edu.cn%2Fnew%2Findex.html{ &quot;username&quot;: &quot;11111111&quot;, &quot;password&quot;: &quot;zWNWg/d0gFfOD2e1+d6muP6UKh7Awx1a+vkE42QyTKGwg/iRUtqYRm9XUNKw3InmCBRBgILnX0eyAAeN/ENKnm8WDxTE27z8Hrvn2eZQL4w=&quot;, &quot;lt&quot;: &quot;LT-443257-YMoeFwN60aKuJdJK9uMpcZloda60qN1655193987483-WBvX-cas&quot;, &quot;dllt&quot;: &quot;userNamePasswordLogin&quot;, &quot;execution&quot;: &quot;e2s1&quot;, &quot;_eventId&quot;: &quot;submit&quot;, &quot;rmShown&quot;: &quot;1&quot;} 发现 Password 是加密的，lt 是变动的 execution 是随机的 参数分析password 在 Dom 事件中点击 发现 login 函数 跟进后发现了关键函数 1234567891011121314151617function _etd(_p0) { try { var _p2 = encryptAES(_p0, pwdDefaultEncryptSalt) $('#casLoginForm').find('#passwordEncrypt').val(_p2) } catch (e) { $('#casLoginForm').find('#passwordEncrypt').val(_p0) }}function _etd2(_p0, _p1) { try { var _p2 = encryptAES(_p0, _p1) $('#casLoginForm').find('#passwordEncrypt').val(_p2) } catch (e) { $('#casLoginForm').find('#passwordEncrypt').val(_p0) }} 关键函数：encryptAES(_p0, pwdDefaultEncryptSalt); 进一步跟 发现这个 p0 就是 密码 p1 就是 key 点进去 encrypt 这个函数 所以我们只需要原封不动的扣下来就可以了，加密函数有了，接下来就是寻找这个 p1 是怎么生成的 1casLoginForm.find('#pwdDefaultEncryptSalt').val() 找到了 是加载页面的时候 有个隐藏的元素 这个值是自动生成的所以 所以我们只需要访问的时候把这个值用解析的方式把他拿出来就行了， 在这里我选择的是用 BeautfulSoup 这个库 其他参数1234567soup = BeautifulSoup(html,'html.parser')ltDom = soup.find('input',attrs={'name': &quot;lt&quot;})exDom = soup.find('input',attrs={'name':'execution'})lt = ltDom[&quot;value&quot;]execution = exDom[&quot;value&quot;]keyDom = soup.find('input',attrs={'id':'pwdDefaultEncryptSalt'})key = keyDom[&quot;value&quot;] 用 python 来发包测试 1234567891011121314151617181920'''发送登录包'''#password = jsFunc.call('encryptAES',PASS_WORD,key)data = { &quot;username&quot;:USER_NAME, &quot;password&quot;:password, &quot;lt&quot;:lt, 'dllt':'userNamePasswordLogin', 'execution':execution, '_eventId':'submit', 'rmShown':1}url = 'http://authserver.tjut.edu.cn/authserver/login?service=http%3A%2F%2Fehall.tjut.edu.cn%2Flogin%3Fservice%3Dhttp%3A%2F%2Fehall.tjut.edu.cn%2Fnew%2Findex.html'res = session.post(url=url,data=data,allow_redirects=False) 登录成功 总结验证码无用当我们登录多次的时候会发现一个验证码 这个验证码没有任何用 不在服务端进行校验 我们只需要用开发者工具删除缓存和清空 Ck 就可以将这个验证 🐎 干掉 登录参数全部在明面上没有任何阻碍就可以获取到这些参数并且模拟出来","link":"/2022/06/14/%E6%9F%90%E5%A4%A7%E5%AD%A6%E4%BF%A1%E6%81%AF%E9%97%A8%E6%88%B7%E7%99%BB%E5%BD%95%E5%88%86%E6%9E%90/"},{"title":"浅谈c++的深拷贝与浅拷贝","text":"初次见面正如字面意思，深与浅无非是拷贝力度的大小。那么怎么理解深和浅呢？ 深：将拷贝对象的所有属性复制一遍 浅：仅拷贝对象的地址 那么为什么要有浅拷贝与深拷贝呢？ 总的目的来说，浅拷贝是为了提高速率，让程序员可以直接操纵对象地址，不用再花时间与内存去复制一份新的出来。显而易见可以看出浅拷贝是很方便操作的。 既然浅拷贝很好 那么我不防聊一聊它的坏处 浅拷贝的坏处程序在设计的初期，并不希望我们把所有的事情都考虑好，更希望程序在运行的过程中自行的去拓展。例如我们要存储一个学生的信息，难道我们一开始就要把学生的最高使用上限就考虑到么，肯定不是的。所以出现了 new 和 delete 。使用 new 创建的变量会放在计算机内存的一个特定部分，直到 delete 调用后这个变量才会删除。这是 new 和 delete 使用的背景。 例子1234567891011121314151617#ifndef STRNGBAD_H__#define STRNGBAD_H__#include &lt;iostream&gt;class StringBad{private: char *str; int len; static int num_strings;public: StringBad(); StringBad(const char *s); ~StringBad(); friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const StringBad &amp;st);};#endif 1234567891011121314151617181920212223242526272829303132333435#include &lt;cstring&gt;#include &quot;strngbad.h&quot;using std::cout;int StringBad::num_strings = 0;StringBad::StringBad(const char *s){ len = std::strlen(s); str = new char[len + 1]; std::strcpy(str, s); num_strings++; cout &lt;&lt; num_strings &lt;&lt; &quot;: \\&quot;&quot; &lt;&lt; str &lt;&lt; &quot;\\&quot; default object created\\n&quot;;}StringBad::StringBad(){ len = 4; str = new char[4]; std::strcpy(str, &quot;c++&quot;); num_strings++; cout &lt;&lt; num_strings &lt;&lt; &quot;: \\&quot;&quot; &lt;&lt; str &lt;&lt; &quot;\\&quot; default object created\\n&quot;;}StringBad::~StringBad(){ cout &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; str &lt;&lt; &quot;\\&quot; object deleted, &quot;; --num_strings; cout &lt;&lt; num_strings &lt;&lt; &quot;left\\n&quot;; delete[] str;}std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const StringBad &amp;st){ os &lt;&lt; st.str; return os;} main.cpp 123456789101112131415161718192021222324252627282930313233343536373839#include &quot;strngbad.h&quot;using std::cout;using std::endl;void callme1(StringBad &amp;);void callme2(StringBad);int main(){ { cout &lt;&lt; &quot;Start&quot; &lt;&lt; endl; StringBad headline1(&quot;Celery Stalk at Midnight&quot;); StringBad headline2(&quot;Lecttuce Prey&quot;); StringBad sports(&quot;Spinach Leaves Bowl for Dollars&quot;); cout &lt;&lt; &quot;head1&quot; &lt;&lt; headline1 &lt;&lt; endl; callme1(headline1); cout &lt;&lt; &quot;head2&quot; &lt;&lt; headline2 &lt;&lt; endl; callme2(headline2); StringBad sailor = sports; cout &lt;&lt; sailor &lt;&lt; endl; StringBad knot; knot = headline1; cout &lt;&lt; knot &lt;&lt; endl; cout &lt;&lt; &quot;exit&quot;; } cout &lt;&lt; &quot;end main&quot;; return 0;}void callme1(StringBad &amp;rsb){ cout &lt;&lt; &quot;String pass by references:\\n&quot;; cout &lt;&lt; &quot;rsb:&quot; &lt;&lt; rsb &lt;&lt; endl;}void callme2(StringBad sb){ cout &lt;&lt; &quot;String pass by references:\\n&quot;; cout &lt;&lt; &quot;sb:&quot; &lt;&lt; sb &lt;&lt; endl;} 当我们编译之后发现程序并没有错误，可是当程序运行的时候，程序会报错，触发了 GPF 错误（GPF 表示程序试图访问禁止的内存单元）这是一种很坏的现象。 1234567891011121314151617181920Start1: &quot;Celery Stalk at Midnight&quot; default object created2: &quot;Lecttuce Prey&quot; default object created3: &quot;Spinach Leaves Bowl for Dollars&quot; default object createdhead1Celery Stalk at MidnightString pass by references:rsb:Celery Stalk at Midnighthead2Lecttuce PreyString pass by references:sb:Lecttuce Prey&quot;Lecttuce Prey&quot; object deleted, 2leftSpinach Leaves Bowl for Dollars3: &quot;c++&quot; default object createdCelery Stalk at Midnightexit&quot;Celery Stalk at Midnight&quot; object deleted, 2left&quot;Spinach Leaves Bowl for Dollars&quot; object deleted, 1left&quot;@Q�eC#&quot; object deleted, 0lefta.out(14353,0x1048b4580) malloc: *** error for object 0x6000011c5140: pointer being freed was not allocateda.out(14353,0x1048b4580) malloc: *** set a breakpoint in malloc_error_break to debugzsh: abort ./a.out 关于为什么会出现错误呢？1.Private 里的 num_strings 错误这种错误主要是程序调用 c++里的默认拷贝函数，复制了一份新的 StringBad 对象，而 Static 静态类型属于整个类并不属于某个对象，故临时产生的 StringBad 对象也会调用析构函数从而导致 num_strings – 2.@Q�eC# 文字乱码12345StringBad sports;sports = headline1;等同于： sports.str = headline1.str;sports.len = headline1.len; 我们可以发现其中 sports.str 只是指向了 headline1.str 的地址，但是由于 headlline1 在销毁的时候会调用 delete 将 str 从内存中删除掉，从而 sports.str 没有地址可寻. 如何解决？创建复制构造函数 1234567StringBad::StringBad(const StringBad &amp; st){ num_strings ++; len = st.len; str = new char [len + 1]; cout &lt;&lt; num_strings &lt;&lt; &quot;: \\&quot;&quot; &lt;&lt; str &lt;&lt; &quot;\\&quot; object created\\n&quot;;}","link":"/2022/02/13/%E6%B5%85%E8%B0%88c-%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/"},{"title":"安卓逆向学习之 FRIDA HOOK AES DES RSA 自吐算法","text":"在分析通信协议的时候 经常遇到的加密算法就是那几个 AES DES 3DES RSA 在 hook AES DES RSA 这些常见的加密算法之前这里先看一下 3 个算法的 java 实现 1 AES 加解密 JAVA 代码实现1.1 AES 加密12345678910111213141516//bytesContent 要加密的数据//key **public static byte[] aes_enc(byte[] bytesContent, String key) throws Exception{ //key相关 byte[] raw = key.getBytes(&quot;utf-8&quot;); SecretKeySpec skeySpec = new SecretKeySpec(raw, &quot;AES&quot;); //&quot;算法/模式/补码方式&quot; 初始化cipher Cipher cipher = Cipher.getInstance(&quot;AES/ECB/PKCS5Padding&quot;); cipher.init(Cipher.ENCRYPT_MODE, skeySpec); //执行加密 byte[] enc = cipher.doFinal(bytesContent); return enc;} 1.2 AES 解密12345678910111213141516//bytesContent 要解密的数据//key **public byte[] aes_dec(byte[] bytesContent, String key) throws Exception{ //key相关 byte[] raw = key.getBytes(&quot;utf-8&quot;); SecretKeySpec skeySpec = new SecretKeySpec(raw, &quot;AES&quot;); //&quot;算法/模式/补码方式&quot; 初始化cipher Cipher cipher = Cipher.getInstance(&quot;AES/ECB/PKCS5Padding&quot;); cipher.init(Cipher.DECRYPT_MODE, skeySpec); //执行解密 byte[] dec = cipher.doFinal(bytesContent); return dec;} 这里 AES 加解密的区别只有一点 123//Cipher.DECRYPT_MODE为解密//Cipher.ENCRYPT_MODE 加密cipher.init(Cipher.DECRYPT_MODE, skeySpec) 2. DES 加解密 JAVA 实现代码2.1 DES 加密12345678910111213141516171819private static byte[] des_enc(byte[] data, byte[] key) throws Exception { // 生成一个可信任的随机数源 SecureRandom sr = new SecureRandom(); // 从原始**数据创建DESKeySpec对象 DESKeySpec dks = new DESKeySpec(key); // 创建一个**工厂，然后用它把DESKeySpec转换成SecretKey对象 SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DES&quot;); SecretKey securekey = keyFactory.generateSecret(dks); // Cipher对象实际完成加密操作 Cipher cipher = Cipher.getInstance(&quot;DES&quot;); // 用**初始化Cipher对象 cipher.init(Cipher.ENCRYPT_MODE, securekey, sr); return cipher.doFinal(data);} 2.2 DES 解密12345678910111213141516171819private static byte[] des_dec(byte[] data, byte[] key) throws Exception { // 生成一个可信任的随机数源 SecureRandom sr = new SecureRandom(); // 从原始**数据创建DESKeySpec对象 DESKeySpec dks = new DESKeySpec(key); // 创建一个**工厂，然后用它把DESKeySpec转换成SecretKey对象 SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DES&quot;); SecretKey securekey = keyFactory.generateSecret(dks); // Cipher对象实际完成解密操作 Cipher cipher = Cipher.getInstance(&quot;DES&quot;); // 用**初始化Cipher对象 cipher.init(Cipher.DECRYPT_MODE, securekey, sr); return cipher.doFinal(data);} 这里 DES 加解密的区别只有一点 123//Cipher.DECRYPT_MODE为解密//Cipher.ENCRYPT_MODE 加密cipher.init(Cipher.DECRYPT_MODE, securekey, sr); 3. RSA 加解密 JAVA 代码实现RSA 加解密代码实现1234567891011121314151617181920212223public static void RSA(byte[] bytesData) throws Exception{ //秘钥长度为1024 生成秘钥对 KeyPairGenerator keyPairGenerator=KeyPairGenerator.getInstance(&quot;RSA&quot;); keyPairGenerator.initialize(1024); KeyPair keyPair= keyPairGenerator.generateKeyPair(); //获取公钥 私钥 PublicKey publicKey=keyPair.getPublic(); PrivateKey privateKey=keyPair.getPrivate(); //公钥加密 java默认&quot;RSA&quot;=&quot;RSA/ECB/PKCS1Padding&quot; Cipher cipher=Cipher.getInstance(&quot;RSA&quot;); cipher.init(Cipher.ENCRYPT_MODE, publicKey); byte[] encBytes = cipher.doFinal(bytesData); //私钥解密 java默认&quot;RSA&quot;=&quot;RSA/ECB/PKCS1Padding&quot; Cipher cipher1=Cipher.getInstance(&quot;RSA&quot;); cipher1.init(Cipher.DECRYPT_MODE, privateKey); byte[] decBytes = cipher1.doFinal(encBytes); Log.d(&quot;xxx&quot;,new String(decBytes));} 这里忽略前面 RSA 加解密都需要的生成公钥私钥的部分核心功能代码如下 3.1 RSA 加密代码1234//公钥加密 java默认&quot;RSA&quot;=&quot;RSA/ECB/PKCS1Padding&quot;Cipher cipher=Cipher.getInstance(&quot;RSA&quot;);cipher.init(Cipher.ENCRYPT_MODE, publicKey);byte[] encBytes = cipher.doFinal(bytesData); 3.2 RSA 解密代码1234//私钥解密 java默认&quot;RSA&quot;=&quot;RSA/ECB/PKCS1Padding&quot;Cipher cipher1=Cipher.getInstance(&quot;RSA&quot;);cipher1.init(Cipher.DECRYPT_MODE, privateKey);byte[] decBytes = cipher1.doFinal(encBytes); 这里 RSA 加解密的区别也只有一点 123//Cipher.DECRYPT_MODE为解密 publicKey 公钥加密//Cipher.ENCRYPT_MODE为加密 privateKey 私钥解密cipher.init(Cipher.ENCRYPT_MODE, publicKey); 看了上面的一些代码 这里可以找到一些共性虽然实现处有些区别 但大体架构和使用的 java 接口是可以找到一些规律的 这里出镜率比较高的有 secretKeySpec Cipher.getInstance cipher.init cipher.doFinal DESKeySpec …(后续还有 这里不一一列举) 查阅 java 帮助文档可以发现, 这些 API 都是一些加密算法常用的接口, 那么实现自吐 就是 hook 加密算法常用的 API,打印相关参数,以便于快速的定位算法和相关参数 加密模式等 在网上查找 相关资料 我找到了一份 frida 自吐算法的源码 链接如下https://blog.csdn.net/weixin_34365417/article/details/93088342 看了上面的源码 作者写的还是不错的 而且不仅 hook 了 我上面提到的加密算法 还 hook 了一些消息摘要算法 MAC 家族和 md 家族等 也就是 md5 sha 等通信协议中常用的 hash 算法 另外也有对 IV 这种加密中用到的向量成员的 hook 这里 我修改了下源码修改的部分主要分为下面几点 针对上面的打印堆栈的代码做了修改 修复在高版本 打印堆栈不换行的问题 增加了一些 hook api 把原来的 python 脚本换成了 js 修复一个 bug ui 调整 增加显示 加密模式 解密模式 把原脚本的 dec 结果 改成 str 结果 增加 dofinal str 显示 4 修改后的源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578var N_ENCRYPT_MODE = 1var N_DECRYPT_MODE = 2function showStacks() { var Exception = Java.use(&quot;java.lang.Exception&quot;); var ins = Exception.$new(&quot;Exception&quot;); var straces = ins.getStackTrace(); if (undefined == straces || null == straces) { return; } console.log(&quot;============================= Stack strat=======================&quot;); console.log(&quot;&quot;); for (var i = 0; i &lt; straces.length; i++) { var str = &quot; &quot; + straces[i].toString(); console.log(str); } console.log(&quot;&quot;); console.log(&quot;============================= Stack end=======================\\r\\n&quot;); Exception.$dispose();}//工具相关函数var base64EncodeChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/', base64DecodeChars = new Array((-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), 62, (-1), (-1), (-1), 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, (-1), (-1), (-1), (-1), (-1), (-1), (-1), 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, (-1), (-1), (-1), (-1), (-1), (-1), 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, (-1), (-1), (-1), (-1), (-1));function stringToBase64(e) { var r, a, c, h, o, t; for (c = e.length, a = 0, r = ''; a &lt; c;) { if (h = 255 &amp; e.charCodeAt(a++), a == c) { r += base64EncodeChars.charAt(h &gt;&gt; 2), r += base64EncodeChars.charAt((3 &amp; h) &lt;&lt; 4), r += '=='; break } if (o = e.charCodeAt(a++), a == c) { r += base64EncodeChars.charAt(h &gt;&gt; 2), r += base64EncodeChars.charAt((3 &amp; h) &lt;&lt; 4 | (240 &amp; o) &gt;&gt; 4), r += base64EncodeChars.charAt((15 &amp; o) &lt;&lt; 2), r += '='; break } t = e.charCodeAt(a++), r += base64EncodeChars.charAt(h &gt;&gt; 2), r += base64EncodeChars.charAt((3 &amp; h) &lt;&lt; 4 | (240 &amp; o) &gt;&gt; 4), r += base64EncodeChars.charAt((15 &amp; o) &lt;&lt; 2 | (192 &amp; t) &gt;&gt; 6), r += base64EncodeChars.charAt(63 &amp; t) } return r}function base64ToString(e) { var r, a, c, h, o, t, d; for (t = e.length, o = 0, d = ''; o &lt; t;) { do r = base64DecodeChars[255 &amp; e.charCodeAt(o++)]; while (o &lt; t &amp;&amp; r == -1); if (r == -1) break; do a = base64DecodeChars[255 &amp; e.charCodeAt(o++)]; while (o &lt; t &amp;&amp; a == -1); if (a == -1) break; d += String.fromCharCode(r &lt;&lt; 2 | (48 &amp; a) &gt;&gt; 4); do { if (c = 255 &amp; e.charCodeAt(o++), 61 == c) return d; c = base64DecodeChars[c] } while (o &lt; t &amp;&amp; c == -1); if (c == -1) break; d += String.fromCharCode((15 &amp; a) &lt;&lt; 4 | (60 &amp; c) &gt;&gt; 2); do { if (h = 255 &amp; e.charCodeAt(o++), 61 == h) return d; h = base64DecodeChars[h] } while (o &lt; t &amp;&amp; h == -1); if (h == -1) break; d += String.fromCharCode((3 &amp; c) &lt;&lt; 6 | h) } return d}function hexToBase64(str) { return base64Encode(String.fromCharCode.apply(null, str.replace(/\\r|\\n/g, &quot;&quot;).replace(/([\\da-fA-F]{2}) ?/g, &quot;0x$1 &quot;).replace(/ +$/, &quot;&quot;).split(&quot; &quot;)));}function base64ToHex(str) { for (var i = 0, bin = base64Decode(str.replace(/[ \\r\\n]+$/, &quot;&quot;)), hex = []; i &lt; bin.length; ++i) { var tmp = bin.charCodeAt(i).toString(16); if (tmp.length === 1) tmp = &quot;0&quot; + tmp; hex[hex.length] = tmp; } return hex.join(&quot;&quot;);}function hexToBytes(str) { var pos = 0; var len = str.length; if (len % 2 != 0) { return null; } len /= 2; var hexA = new Array(); for (var i = 0; i &lt; len; i++) { var s = str.substr(pos, 2); var v = parseInt(s, 16); hexA.push(v); pos += 2; } return hexA;}function bytesToHex(arr) { var str = ''; var k, j; for (var i = 0; i &lt; arr.length; i++) { k = arr[i]; j = k; if (k &lt; 0) { j = k + 256; } if (j &lt; 16) { str += &quot;0&quot;; } str += j.toString(16); } return str;}function stringToHex(str) { var val = &quot;&quot;; for (var i = 0; i &lt; str.length; i++) { if (val == &quot;&quot;) val = str.charCodeAt(i).toString(16); else val += str.charCodeAt(i).toString(16); } return val}function stringToBytes(str) { var ch, st, re = []; for (var i = 0; i &lt; str.length; i++) { ch = str.charCodeAt(i); st = []; do { st.push(ch &amp; 0xFF); ch = ch &gt;&gt; 8; } while (ch); re = re.concat(st.reverse()); } return re;}//将byte[]转成String的方法function bytesToString(arr) { var str = ''; arr = new Uint8Array(arr); for (var i in arr) { str += String.fromCharCode(arr[i]); } return str;}function bytesToBase64(e) { var r, a, c, h, o, t; for (c = e.length, a = 0, r = ''; a &lt; c;) { if (h = 255 &amp; e[a++], a == c) { r += base64EncodeChars.charAt(h &gt;&gt; 2), r += base64EncodeChars.charAt((3 &amp; h) &lt;&lt; 4), r += '=='; break } if (o = e[a++], a == c) { r += base64EncodeChars.charAt(h &gt;&gt; 2), r += base64EncodeChars.charAt((3 &amp; h) &lt;&lt; 4 | (240 &amp; o) &gt;&gt; 4), r += base64EncodeChars.charAt((15 &amp; o) &lt;&lt; 2), r += '='; break } t = e[a++], r += base64EncodeChars.charAt(h &gt;&gt; 2), r += base64EncodeChars.charAt((3 &amp; h) &lt;&lt; 4 | (240 &amp; o) &gt;&gt; 4), r += base64EncodeChars.charAt((15 &amp; o) &lt;&lt; 2 | (192 &amp; t) &gt;&gt; 6), r += base64EncodeChars.charAt(63 &amp; t) } return r}function base64ToBytes(e) { var r, a, c, h, o, t, d; for (t = e.length, o = 0, d = []; o &lt; t;) { do r = base64DecodeChars[255 &amp; e.charCodeAt(o++)]; while (o &lt; t &amp;&amp; r == -1); if (r == -1) break; do a = base64DecodeChars[255 &amp; e.charCodeAt(o++)]; while (o &lt; t &amp;&amp; a == -1); if (a == -1) break; d.push(r &lt;&lt; 2 | (48 &amp; a) &gt;&gt; 4); do { if (c = 255 &amp; e.charCodeAt(o++), 61 == c) return d; c = base64DecodeChars[c] } while (o &lt; t &amp;&amp; c == -1); if (c == -1) break; d.push((15 &amp; a) &lt;&lt; 4 | (60 &amp; c) &gt;&gt; 2); do { if (h = 255 &amp; e.charCodeAt(o++), 61 == h) return d; h = base64DecodeChars[h] } while (o &lt; t &amp;&amp; h == -1); if (h == -1) break; d.push((3 &amp; c) &lt;&lt; 6 | h) } return d}//stringToBase64 stringToHex stringToBytes//base64ToString base64ToHex base64ToBytes// hexToBase64 hexToBytes// bytesToBase64 bytesToHex bytesToStringJava.perform(function () { var secretKeySpec = Java.use('javax.crypto.spec.SecretKeySpec'); secretKeySpec.$init.overload('[B', 'java.lang.String').implementation = function (a, b) { showStacks(); var result = this.$init(a, b); console.log(&quot;======================================&quot;); console.log(&quot;算法名：&quot; + b + &quot;|str**:&quot; + bytesToString(a)); console.log(&quot;算法名：&quot; + b + &quot;|Hex**:&quot; + bytesToHex(a)); return result; } var DESKeySpec = Java.use('javax.crypto.spec.DESKeySpec'); DESKeySpec.$init.overload('[B').implementation = function (a) { showStacks(); var result = this.$init(a); console.log(&quot;======================================&quot;); var bytes_key_des = this.getKey(); console.log(&quot;des** |str &quot; + bytesToString(bytes_key_des)); console.log(&quot;des** |hex &quot; + bytesToHex(bytes_key_des)); return result; } DESKeySpec.$init.overload('[B', 'int').implementation = function (a, b) { showStacks(); var result = this.$init(a, b); console.log(&quot;======================================&quot;); var bytes_key_des = this.getKey(); console.log(&quot;des** |str &quot; + bytesToString(bytes_key_des)); console.log(&quot;des** |hex &quot; + bytesToHex(bytes_key_des)); return result; } var mac = Java.use('javax.crypto.Mac'); mac.getInstance.overload('java.lang.String').implementation = function (a) { showStacks(); var result = this.getInstance(a); console.log(&quot;======================================&quot;); console.log(&quot;算法名：&quot; + a); return result; } mac.update.overload('[B').implementation = function (a) { //showStacks(); this.update(a); console.log(&quot;======================================&quot;); console.log(&quot;update:&quot; + bytesToString(a)) } mac.update.overload('[B', 'int', 'int').implementation = function (a, b, c) { //showStacks(); this.update(a, b, c) console.log(&quot;======================================&quot;); console.log(&quot;update:&quot; + bytesToString(a) + &quot;|&quot; + b + &quot;|&quot; + c); } mac.doFinal.overload().implementation = function () { //showStacks(); var result = this.doFinal(); console.log(&quot;======================================&quot;); console.log(&quot;doFinal结果: |str :&quot; + bytesToString(result)); console.log(&quot;doFinal结果: |hex :&quot; + bytesToHex(result)); console.log(&quot;doFinal结果: |base64 :&quot; + bytesToBase64(result)); return result; } mac.doFinal.overload('[B').implementation = function (a) { //showStacks(); var result = this.doFinal(a); console.log(&quot;======================================&quot;); console.log(&quot;doFinal参数: |str :&quot; + bytesToString(a)); console.log(&quot;doFinal结果: |str :&quot; + bytesToString(result)); console.log(&quot;doFinal结果: |hex :&quot; + bytesToHex(result)); console.log(&quot;doFinal结果: |base64 :&quot; + bytesToBase64(result)); return result; } var md = Java.use('java.security.MessageDigest'); md.getInstance.overload('java.lang.String', 'java.lang.String').implementation = function (a, b) { //showStacks(); console.log(&quot;======================================&quot;); console.log(&quot;算法名：&quot; + a); return this.getInstance(a, b); } md.getInstance.overload('java.lang.String').implementation = function (a) { //showStacks(); console.log(&quot;======================================&quot;); console.log(&quot;算法名：&quot; + a); return this.getInstance(a); } md.update.overload('[B').implementation = function (a) { //showStacks(); console.log(&quot;======================================&quot;); console.log(&quot;update:&quot; + bytesToString(a)) return this.update(a); } md.update.overload('[B', 'int', 'int').implementation = function (a, b, c) { //showStacks(); console.log(&quot;======================================&quot;); console.log(&quot;update:&quot; + bytesToString(a) + &quot;|&quot; + b + &quot;|&quot; + c); return this.update(a, b, c); } md.digest.overload().implementation = function () { //showStacks(); console.log(&quot;======================================&quot;); var result = this.digest(); console.log(&quot;digest结果:&quot; + bytesToHex(result)); console.log(&quot;digest结果:&quot; + bytesToBase64(result)); return result; } md.digest.overload('[B').implementation = function (a) { //showStacks(); console.log(&quot;======================================&quot;); console.log(&quot;digest参数:&quot; + bytesToString(a)); var result = this.digest(a); console.log(&quot;digest结果:&quot; + bytesToHex(result)); console.log(&quot;digest结果:&quot; + bytesToBase64(result)); return result; } var ivParameterSpec = Java.use('javax.crypto.spec.IvParameterSpec'); ivParameterSpec.$init.overload('[B').implementation = function (a) { //showStacks(); var result = this.$init(a); console.log(&quot;======================================&quot;); console.log(&quot;iv向量: |str:&quot; + bytesToString(a)); console.log(&quot;iv向量: |hex:&quot; + bytesToHex(a)); return result; } var cipher = Java.use('javax.crypto.Cipher'); cipher.getInstance.overload('java.lang.String').implementation = function (a) { //showStacks(); var result = this.getInstance(a); console.log(&quot;======================================&quot;); console.log(&quot;模式填充:&quot; + a); return result; } cipher.init.overload('int', 'java.security.Key').implementation = function (a, b) { //showStacks(); var result = this.init(a, b); console.log(&quot;======================================&quot;); if (N_ENCRYPT_MODE == a) { console.log(&quot;init | 加密模式&quot;); } else if(N_DECRYPT_MODE == a) { console.log(&quot;init | 解密模式&quot;); } var bytes_key = b.getEncoded(); console.log(&quot;init key:&quot; + &quot;|str**:&quot; + bytesToString(bytes_key)); console.log(&quot;init key:&quot; + &quot;|Hex**:&quot; + bytesToHex(bytes_key)); return result; } cipher.init.overload('int', 'java.security.cert.Certificate').implementation = function (a, b) { //showStacks(); var result = this.init(a, b); console.log(&quot;======================================&quot;); if (N_ENCRYPT_MODE == a) { console.log(&quot;init | 加密模式&quot;); } else if(N_DECRYPT_MODE == a) { console.log(&quot;init | 解密模式&quot;); } return result; } cipher.init.overload('int', 'java.security.Key', 'java.security.spec.AlgorithmParameterSpec').implementation = function (a, b, c) { //showStacks(); var result = this.init(a, b, c); console.log(&quot;======================================&quot;); if (N_ENCRYPT_MODE == a) { console.log(&quot;init | 加密模式&quot;); } else if(N_DECRYPT_MODE == a) { console.log(&quot;init | 解密模式&quot;); } var bytes_key = b.getEncoded(); console.log(&quot;init key:&quot; + &quot;|str**:&quot; + bytesToString(bytes_key)); console.log(&quot;init key:&quot; + &quot;|Hex**:&quot; + bytesToHex(bytes_key)); return result; } cipher.init.overload('int', 'java.security.cert.Certificate', 'java.security.SecureRandom').implementation = function (a, b, c) { //showStacks(); var result = this.init(a, b, c); if (N_ENCRYPT_MODE == a) { console.log(&quot;init | 加密模式&quot;); } else if(N_DECRYPT_MODE == a) { console.log(&quot;init | 解密模式&quot;); } return result; } cipher.init.overload('int', 'java.security.Key', 'java.security.SecureRandom').implementation = function (a, b, c) { //showStacks(); var result = this.init(a, b, c); if (N_ENCRYPT_MODE == a) { console.log(&quot;init | 加密模式&quot;); } else if(N_DECRYPT_MODE == a) { console.log(&quot;init | 解密模式&quot;); } var bytes_key = b.getEncoded(); console.log(&quot;init key:&quot; + &quot;|str**:&quot; + bytesToString(bytes_key)); console.log(&quot;init key:&quot; + &quot;|Hex**:&quot; + bytesToHex(bytes_key)); return result; } cipher.init.overload('int', 'java.security.Key', 'java.security.AlgorithmParameters').implementation = function (a, b, c) { //showStacks(); var result = this.init(a, b, c); if (N_ENCRYPT_MODE == a) { console.log(&quot;init | 加密模式&quot;); } else if(N_DECRYPT_MODE == a) { console.log(&quot;init | 解密模式&quot;); } var bytes_key = b.getEncoded(); console.log(&quot;init key:&quot; + &quot;|str**:&quot; + bytesToString(bytes_key)); console.log(&quot;init key:&quot; + &quot;|Hex**:&quot; + bytesToHex(bytes_key)); return result; } cipher.init.overload('int', 'java.security.Key', 'java.security.AlgorithmParameters', 'java.security.SecureRandom').implementation = function (a, b, c, d) { //showStacks(); var result = this.init(a, b, c, d); if (N_ENCRYPT_MODE == a) { console.log(&quot;init | 加密模式&quot;); } else if(N_DECRYPT_MODE == a) { console.log(&quot;init | 解密模式&quot;); } var bytes_key = b.getEncoded(); console.log(&quot;init key:&quot; + &quot;|str**:&quot; + bytesToString(bytes_key)); console.log(&quot;init key:&quot; + &quot;|Hex**:&quot; + bytesToHex(bytes_key)); return result; } cipher.init.overload('int', 'java.security.Key', 'java.security.spec.AlgorithmParameterSpec', 'java.security.SecureRandom').implementation = function (a, b, c, d) { //showStacks(); var result = this.update(a, b, c, d); if (N_ENCRYPT_MODE == a) { console.log(&quot;init | 加密模式&quot;); } else if(N_DECRYPT_MODE == a) { console.log(&quot;init | 解密模式&quot;); } var bytes_key = b.getEncoded(); console.log(&quot;init key:&quot; + &quot;|str**:&quot; + bytesToString(bytes_key)); console.log(&quot;init key:&quot; + &quot;|Hex**:&quot; + bytesToHex(bytes_key)); return result; } cipher.update.overload('[B').implementation = function (a) { //showStacks(); var result = this.update(a); console.log(&quot;======================================&quot;); console.log(&quot;update:&quot; + bytesToString(a)); return result; } cipher.update.overload('[B', 'int', 'int').implementation = function (a, b, c) { //showStacks(); var result = this.update(a, b, c); console.log(&quot;======================================&quot;); console.log(&quot;update:&quot; + bytesToString(a) + &quot;|&quot; + b + &quot;|&quot; + c); return result; } cipher.doFinal.overload().implementation = function () { //showStacks(); var result = this.doFinal(); console.log(&quot;======================================&quot;); console.log(&quot;doFinal结果: |str :&quot; + bytesToString(result)); console.log(&quot;doFinal结果: |hex :&quot; + bytesToHex(result)); console.log(&quot;doFinal结果: |base64 :&quot; + bytesToBase64(result)); return result; } cipher.doFinal.overload('[B').implementation = function (a) { //showStacks(); var result = this.doFinal(a); console.log(&quot;======================================&quot;); console.log(&quot;doFinal参数: |str :&quot; + bytesToString(a)); console.log(&quot;doFinal结果: |str :&quot; + bytesToString(result)); console.log(&quot;doFinal结果: |hex :&quot; + bytesToHex(result)); console.log(&quot;doFinal结果: |base64 :&quot; + bytesToBase64(result)); return result; } var x509EncodedKeySpec = Java.use('java.security.spec.X509EncodedKeySpec'); x509EncodedKeySpec.$init.overload('[B').implementation = function (a) { //showStacks(); var result = this.$init(a); console.log(&quot;======================================&quot;); console.log(&quot;RSA**:&quot; + bytesToBase64(a)); return result; } var rSAPublicKeySpec = Java.use('java.security.spec.RSAPublicKeySpec'); rSAPublicKeySpec.$init.overload('java.math.BigInteger', 'java.math.BigInteger').implementation = function (a, b) { //showStacks(); var result = this.$init(a, b); console.log(&quot;======================================&quot;); //console.log(&quot;RSA**:&quot; + bytesToBase64(a)); console.log(&quot;RSA**N:&quot; + a.toString(16)); console.log(&quot;RSA**E:&quot; + b.toString(16)); return result; } var KeyPairGenerator = Java.use('java.security.KeyPairGenerator'); KeyPairGenerator.generateKeyPair.implementation = function () { //showStacks(); var result = this.generateKeyPair(); console.log(&quot;======================================&quot;); var str_private = result.getPrivate().getEncoded(); var str_public = result.getPublic().getEncoded(); console.log(&quot;公钥 |hex&quot; + bytesToHex(str_public)); console.log(&quot;私钥 |hex&quot; + bytesToHex(str_private)); return result; } KeyPairGenerator.genKeyPair.implementation = function () { //showStacks(); var result = this.genKeyPair(); console.log(&quot;======================================&quot;); var str_private = result.getPrivate().getEncoded(); var str_public = result.getPublic().getEncoded(); console.log(&quot;公钥 |hex&quot; + bytesToHex(str_public)); console.log(&quot;私钥 |hex&quot; + bytesToHex(str_private)); return result; }});","link":"/2022/06/13/Firda%E7%94%A8%E6%B3%95/"},{"title":"【实战】某习通app逆向分析（二）发包参数加密分析、解密和数据采集","text":"前言在上一章中我们静态分析了 Frida 的拍照与检测，这一章我们来分析学习通抓包里的参数分析，解密与数据采集【实战】某习通 app 逆向分析（一）检测切屏、拍照、上传 准备工作模拟器 Fidder Charles + Postern Frida monitor 开始抓包登录打开学习通 点击登录 通过分析 我们发现他是双向证书校验，如何绕过双向证书呢 把 app 里面的证书导出导入到抓包工具 通过 hook 干掉 Client cer pfx p12 plc bks crt 包含这些关键词的函数。 在这里我们使用双向证书 Hook 的方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424Java.perform(function () { /*hook list:1.SSLcontext2.okhttp3.webview4.XUtils5.httpclientandroidlib6.JSSE7.network\\_security\\_config (android 7.0+)8.Apache Http client (support partly)9.OpenSSLSocketImpl10.TrustKit11.Cronet*/ // Attempts to bypass SSL pinning implementations in a number of // ways. These include implementing a new TrustManager that will // accept any SSL certificate, overriding OkHTTP v3 check() // method etc. var X509TrustManager = Java.use('javax.net.ssl.X509TrustManager') var HostnameVerifier = Java.use('javax.net.ssl.HostnameVerifier') var SSLContext = Java.use('javax.net.ssl.SSLContext') var quiet_output = false // Helper method to honor the quiet flag. function quiet_send(data) { if (quiet_output) { return } send(data) } // Implement a new TrustManager // ref: https://gist.github.com/oleavr/3ca67a173ff7d207c6b8c3b0ca65a9d8 // Java.registerClass() is only supported on ART for now(201803). 所以android 4.4以下不兼容,4.4要切换成ART使用. /*06-07 16:15:38.541 27021-27073/mi.sslpinningdemo W/System.err: java.lang.IllegalArgumentException: Required method checkServerTrusted(X509Certificate[], String, String, String) missing06-07 16:15:38.542 27021-27073/mi.sslpinningdemo W/System.err: at android.net.http.X509TrustManagerExtensions.&lt;init&gt;(X509TrustManagerExtensions.java:73) at mi.ssl.MiPinningTrustManger.&lt;init&gt;(MiPinningTrustManger.java:61)06-07 16:15:38.543 27021-27073/mi.sslpinningdemo W/System.err: at mi.sslpinningdemo.OkHttpUtil.getSecPinningClient(OkHttpUtil.java:112) at mi.sslpinningdemo.OkHttpUtil.get(OkHttpUtil.java:62) at mi.sslpinningdemo.MainActivity$1$1.run(MainActivity.java:36)*/ var X509Certificate = Java.use('java.security.cert.X509Certificate') var TrustManager try { TrustManager = Java.registerClass({ name: 'org.wooyun.TrustManager', implements: [X509TrustManager], methods: { checkClientTrusted: function (chain, authType) {}, checkServerTrusted: function (chain, authType) {}, getAcceptedIssuers: function () { // var certs = [X509Certificate.$new()]; // return certs; return [] }, }, }) } catch (e) { quiet_send('registerClass from X509TrustManager &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ' + e.message) } // Prepare the TrustManagers array to pass to SSLContext.init() var TrustManagers = [TrustManager.$new()] try { // Prepare a Empty SSLFactory var TLS_SSLContext = SSLContext.getInstance('TLS') TLS_SSLContext.init(null, TrustManagers, null) var EmptySSLFactory = TLS_SSLContext.getSocketFactory() } catch (e) { quiet_send(e.message) } send('Custom, Empty TrustManager ready') // Get a handle on the init() on the SSLContext class var SSLContext_init = SSLContext.init.overload( '[Ljavax.net.ssl.KeyManager;', '[Ljavax.net.ssl.TrustManager;', 'java.security.SecureRandom' ) // Override the init method, specifying our new TrustManager SSLContext_init.implementation = function ( keyManager, trustManager, secureRandom ) { quiet_send('Overriding SSLContext.init() with the custom TrustManager') SSLContext_init.call(this, null, TrustManagers, null) } /*** okhttp3.x unpinning ***/ // Wrap the logic in a try/catch as not all applications will have // okhttp as part of the app. try { var CertificatePinner = Java.use('okhttp3.CertificatePinner') quiet_send('OkHTTP 3.x Found') CertificatePinner.check.overload( 'java.lang.String', 'java.util.List' ).implementation = function () { quiet_send('OkHTTP 3.x check() called. Not throwing an exception.') } } catch (err) { // If we dont have a ClassNotFoundException exception, raise the // problem encountered. if (err.message.indexOf('ClassNotFoundException') === 0) { throw new Error(err) } } // Appcelerator Titanium PinningTrustManager // Wrap the logic in a try/catch as not all applications will have // appcelerator as part of the app. try { var PinningTrustManager = Java.use('appcelerator.https.PinningTrustManager') send('Appcelerator Titanium Found') PinningTrustManager.checkServerTrusted.implementation = function () { quiet_send( 'Appcelerator checkServerTrusted() called. Not throwing an exception.' ) } } catch (err) { // If we dont have a ClassNotFoundException exception, raise the // problem encountered. if (err.message.indexOf('ClassNotFoundException') === 0) { throw new Error(err) } } /*** okhttp unpinning ***/ try { var OkHttpClient = Java.use('com.squareup.okhttp.OkHttpClient') OkHttpClient.setCertificatePinner.implementation = function ( certificatePinner ) { // do nothing quiet_send('OkHttpClient.setCertificatePinner Called!') return this } // Invalidate the certificate pinnet checks (if &quot;setCertificatePinner&quot; was called before the previous invalidation) var CertificatePinner = Java.use('com.squareup.okhttp.CertificatePinner') CertificatePinner.check.overload( 'java.lang.String', '[Ljava.security.cert.Certificate;' ).implementation = function (p0, p1) { // do nothing quiet_send('okhttp Called! [Certificate]') return } CertificatePinner.check.overload( 'java.lang.String', 'java.util.List' ).implementation = function (p0, p1) { // do nothing quiet_send('okhttp Called! [List]') return } } catch (e) { quiet_send('com.squareup.okhttp not found') } /*** WebView Hooks ***/ /* frameworks/base/core/java/android/webkit/WebViewClient.java */ /* public void onReceivedSslError(Webview, SslErrorHandler, SslError) */ var WebViewClient = Java.use('android.webkit.WebViewClient') WebViewClient.onReceivedSslError.implementation = function ( webView, sslErrorHandler, sslError ) { quiet_send('WebViewClient onReceivedSslError invoke') //执行proceed方法 sslErrorHandler.proceed() return } WebViewClient.onReceivedError.overload( 'android.webkit.WebView', 'int', 'java.lang.String', 'java.lang.String' ).implementation = function (a, b, c, d) { quiet_send('WebViewClient onReceivedError invoked') return } WebViewClient.onReceivedError.overload( 'android.webkit.WebView', 'android.webkit.WebResourceRequest', 'android.webkit.WebResourceError' ).implementation = function () { quiet_send('WebViewClient onReceivedError invoked') return } /*** JSSE Hooks ***/ /* libcore/luni/src/main/java/javax/net/ssl/TrustManagerFactory.java */ /* public final TrustManager[] getTrustManager() */ /* TrustManagerFactory.getTrustManagers maybe cause X509TrustManagerExtensions error */ // var TrustManagerFactory = Java.use(&quot;javax.net.ssl.TrustManagerFactory&quot;); // TrustManagerFactory.getTrustManagers.implementation = function(){ // quiet_send(&quot;TrustManagerFactory getTrustManagers invoked&quot;); // return TrustManagers; // } var HttpsURLConnection = Java.use('javax.net.ssl.HttpsURLConnection') /* libcore/luni/src/main/java/javax/net/ssl/HttpsURLConnection.java */ /* public void setDefaultHostnameVerifier(HostnameVerifier) */ HttpsURLConnection.setDefaultHostnameVerifier.implementation = function ( hostnameVerifier ) { quiet_send('HttpsURLConnection.setDefaultHostnameVerifier invoked') return null } /* libcore/luni/src/main/java/javax/net/ssl/HttpsURLConnection.java */ /* public void setSSLSocketFactory(SSLSocketFactory) */ HttpsURLConnection.setSSLSocketFactory.implementation = function ( SSLSocketFactory ) { quiet_send('HttpsURLConnection.setSSLSocketFactory invoked') return null } /* libcore/luni/src/main/java/javax/net/ssl/HttpsURLConnection.java */ /* public void setHostnameVerifier(HostnameVerifier) */ HttpsURLConnection.setHostnameVerifier.implementation = function ( hostnameVerifier ) { quiet_send('HttpsURLConnection.setHostnameVerifier invoked') return null } /*** Xutils3.x hooks ***/ //Implement a new HostnameVerifier var TrustHostnameVerifier try { TrustHostnameVerifier = Java.registerClass({ name: 'org.wooyun.TrustHostnameVerifier', implements: [HostnameVerifier], method: { verify: function (hostname, session) { return true }, }, }) } catch (e) { //java.lang.ClassNotFoundException: Didn't find class &quot;org.wooyun.TrustHostnameVerifier&quot; quiet_send('registerClass from hostnameVerifier &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ' + e.message) } try { var RequestParams = Java.use('org.xutils.http.RequestParams') RequestParams.setSslSocketFactory.implementation = function ( sslSocketFactory ) { sslSocketFactory = EmptySSLFactory return null } RequestParams.setHostnameVerifier.implementation = function ( hostnameVerifier ) { hostnameVerifier = TrustHostnameVerifier.$new() return null } } catch (e) { quiet_send('Xutils hooks not Found') } /*** httpclientandroidlib Hooks ***/ try { var AbstractVerifier = Java.use( 'ch.boye.httpclientandroidlib.conn.ssl.AbstractVerifier' ) AbstractVerifier.verify.overload( 'java.lang.String', '[Ljava.lang.String', '[Ljava.lang.String', 'boolean' ).implementation = function () { quiet_send('httpclientandroidlib Hooks') return null } } catch (e) { quiet_send('httpclientandroidlib Hooks not found') } /***android 7.0+ network_security_config TrustManagerImpl hookapache httpclient partly***/ var TrustManagerImpl = Java.use('com.android.org.conscrypt.TrustManagerImpl') // try { // var Arrays = Java.use(&quot;java.util.Arrays&quot;); // //apache http client pinning maybe baypass // //https://github.com/google/conscrypt/blob/c88f9f55a523f128f0e4dace76a34724bfa1e88c/platform/src/main/java/org/conscrypt/TrustManagerImpl.java#471 // TrustManagerImpl.checkTrusted.implementation = function (chain, authType, session, parameters, authType) { // quiet_send(&quot;TrustManagerImpl checkTrusted called&quot;); // //Generics currently result in java.lang.Object // return Arrays.asList(chain); // } // // } catch (e) { // quiet_send(&quot;TrustManagerImpl checkTrusted nout found&quot;); // } try { // Android 7+ TrustManagerImpl TrustManagerImpl.verifyChain.implementation = function ( untrustedChain, trustAnchorChain, host, clientAuth, ocspData, tlsSctData ) { quiet_send('TrustManagerImpl verifyChain called') // Skip all the logic and just return the chain again :P //https://www.nccgroup.trust/uk/about-us/newsroom-and-events/blogs/2017/november/bypassing-androids-network-security-configuration/ // https://github.com/google/conscrypt/blob/c88f9f55a523f128f0e4dace76a34724bfa1e88c/platform/src/main/java/org/conscrypt/TrustManagerImpl.java#L650 return untrustedChain } } catch (e) { quiet_send('TrustManagerImpl verifyChain nout found below 7.0') } // OpenSSLSocketImpl try { var OpenSSLSocketImpl = Java.use( 'com.android.org.conscrypt.OpenSSLSocketImpl' ) OpenSSLSocketImpl.verifyCertificateChain.implementation = function ( certRefs, authMethod ) { quiet_send('OpenSSLSocketImpl.verifyCertificateChain') } quiet_send('OpenSSLSocketImpl pinning') } catch (err) { quiet_send('OpenSSLSocketImpl pinner not found') } // Trustkit try { var Activity = Java.use( 'com.datatheorem.android.trustkit.pinning.OkHostnameVerifier' ) Activity.verify.overload( 'java.lang.String', 'javax.net.ssl.SSLSession' ).implementation = function (str) { quiet_send('Trustkit.verify1: ' + str) return true } Activity.verify.overload( 'java.lang.String', 'java.security.cert.X509Certificate' ).implementation = function (str) { quiet_send('Trustkit.verify2: ' + str) return true } quiet_send('Trustkit pinning') } catch (err) { quiet_send('Trustkit pinner not found') } try { //cronet pinner hook //weibo don't invoke var netBuilder = Java.use('org.chromium.net.CronetEngine$Builder') //https://developer.android.com/guide/topics/connectivity/cronet/reference/org/chromium/net/CronetEngine.Builder.html#enablePublicKeyPinningBypassForLocalTrustAnchors(boolean) netBuilder.enablePublicKeyPinningBypassForLocalTrustAnchors.implementation = function (arg) { //weibo not invoke console.log( 'Enables or disables public key pinning bypass for local trust anchors = ' + arg ) //true to enable the bypass, false to disable. var ret = netBuilder.enablePublicKeyPinningBypassForLocalTrustAnchors.call( this, true ) return ret } netBuilder.addPublicKeyPins.implementation = function ( hostName, pinsSha256, includeSubdomains, expirationDate ) { console.log('cronet addPublicKeyPins hostName = ' + hostName) //var ret = netBuilder.addPublicKeyPins.call(this,hostName, pinsSha256,includeSubdomains, expirationDate); //this 是调用 addPublicKeyPins 前的对象吗? Yes,CronetEngine.Builder return this } } catch (err) { console.log('[-] Cronet pinner not found') }}) 去脱壳后的 app 里面分析找 找到了关键类，我们 hook javax.net.ssl 这个类 再次进行抓包 结果出来了 输入正确的账号密码 获取推荐列表 抓包拿到以下这些值 1234567891011121314GET https://home-yd.chaoxing.com/apis/data/getIdxSourceFromRecChaoXing?puid=233132169&amp;cpage=1&amp;size=30&amp;from=xxtclient&amp;token=4faa8662c59590c6f43ae9fe5b002b42&amp;_time=1655478785055&amp;inf_enc=bb0db913892b643161bf55531400e39b HTTP/1.1User-Agent: Dalvik/2.1.0 (Linux; U; Android 7.1.2; PCRT00 Build/N2G48H) com.chaoxing.mobile/ChaoXingStudy_3_4.3.4_android_phone_494_27 (@Kalimdor)_e084defffb7f4ec5a02ea1cb5bd38199Accept-Language: zh_CNHost: home-yd.chaoxing.comConnection: Keep-AliveAccept-Encoding: gzip// ck在这里隐藏了这是一个get请求puid=233132169&amp;cpage=1&amp;size=30&amp;from=xxtclient&amp;token=4faa8662c59590c6f43ae9fe5b002b42&amp;_time=1655478785055&amp;inf_enc=bb0db913892b643161bf55531400e39b 我们进行二次抓包参数对比 time 是时间戳 总结得出 1234token 用户个人的toknepuid 服务器回调参数_time 时间戳inf_enc 加密sing 目标明确 获取这个 inf_enc 找到这个类，编写 frida 进行 hook 目测应该是个 md5 反混淆开启 确认了是我们要的东西，点进去这个 a 看看是啥，把之前的参数删掉与时间戳重新拼接 我们直接上自吐模块 自吐模块可以在我的博客里面搜 由于代码过长 就不在这里写了 抓包得到值：47a7273c8ae78516a453d041a1a77e96 拿到加密字符串 我们再去 Jadx 搜**DESKey=**查看一下这个值是多少 这个问题放到后面再讲 将拿到的字符串放到工具里面生成 与抓包值一样。 到这里就结束了 所以现在我们可以直接写 python 代码了 token=4faa8662c59590c6f43ae9fe5b002b42&amp;_time=1655480519505&amp;DESKey=Z(AfY@XS inf_enc = md5(token + time + Z(AfY@XS) 意外之喜当我在写 python 爬虫的时候发现，这个 Token 并没有返回，而是通过 app 自己计算得出的，在之前的判断中认为 token 是个人的 Token 但是没想到，token 是写死的！！！！！ python 爬虫代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970# -*- coding: utf-8 -*-# @Time : 2022-06-17 23:54# @Author : CodeCat# @File : demo.pyimport timefrom hashlib import md5import requestsfrom loguru import logger'''login'''head = { &quot;User-Agent&quot;: &quot;Dalvik/2.1.0 (Linux; U; Android 7.1.2; PCRT00 Build/N2G48H) com.chaoxing.mobile/ChaoXingStudy_3_4.3.4_android_phone_494_27 (@Kalimdor)_e084defffb7f4ec5a02ea1cb5bd38199&quot;, &quot;Accept-Language&quot;: &quot;zh_CN&quot;, &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;, &quot;Host&quot;: &quot;passport2-api.chaoxing.com&quot;, &quot;Connection&quot;: &quot;Keep-Alive&quot;, &quot;Accept-Encoding&quot;: &quot;gzip&quot;}session = requests.Session()session.headers = headurl = &quot;https://passport2-api.chaoxing.com/v11/loginregister?cx_xxt_passport=json&quot;payload = &quot;uname=&amp;code=&amp;loginType=1&amp;roleSelect=true&quot;retJson = session.post(url,data=payload).json()head = { &quot;User-Agent&quot;: &quot;Dalvik/2.1.0 (Linux; U; Android 7.1.2; PCRT00 Build/N2G48H) com.chaoxing.mobile/ChaoXingStudy_3_4.3.4_android_phone_494_27 (@Kalimdor)_e084defffb7f4ec5a02ea1cb5bd38199&quot;, &quot;Accept-Language&quot;: &quot;zh_CN&quot;, &quot;Host&quot;: &quot;sso.chaoxing.com&quot;, &quot;Connection&quot;: &quot;Keep-Alive&quot;, &quot;Accept-Encoding&quot;: &quot;gzip&quot;}session.headers.update(head)logger.success(retJson)url = &quot;https://sso.chaoxing.com/apis/login/userLogin4Uname.do&quot;retText = session.get(url,allow_redirects=False).textlogger.debug(retText)timestmp = int(time.time() * 1000)logger.info(timestmp)MD5 = md5()msg = &quot;token=4faa8662c59590c6f43ae9fe5b002b42&amp;_time=&quot;+str(timestmp)+&quot;&amp;DESKey=Z(AfY@XS&quot;MD5.update(msg.encode())infEnc = MD5.hexdigest()logger.success(infEnc)url = &quot;https://home-yd.chaoxing.com/apis/data/getAdsRecommend&quot;params = { &quot;token&quot;: &quot;4faa8662c59590c6f43ae9fe5b002b42&quot;, &quot;_time&quot;: timestmp, &quot;inf_enc&quot;: infEnc}head = { &quot;Host&quot;: &quot;home-yd.chaoxing.com&quot;}session.headers.update(head)data = session.get(url,params=params).json()logger.info(data) 这里面有几个协议头的坑需要注意以下，其次再没了。 总结在研究学习通的时候，遇到的问题实在是太多了，从 Frida 检测，Objection 检测，root 检测，双向 SSL 检测。本以为它是简单的双进程，没 想到是多进程保护，属实是破防了，在逆向 app 的时候关键函数加混淆，AES MD5 DES 层出不穷，在接下来中将进一步深入探究学习通 APP。 参考文章： 12345678https://blog.csdn.net/CharlesSimonyi/article/details/90647009https://blog.csdn.net/freeking101/article/details/105759124https://blog.csdn.net/welggy/article/details/121716944https://blog.csdn.net/qq_42196922/article/details/107322504 ​ 如果你愿意参与 Hello Codecat 的网站建设付出一份力，分享有趣好玩的文章、项目与书籍，欢迎联系我：QQ 2372943","link":"/2022/06/18/%E3%80%90%E5%AE%9E%E6%88%98%E3%80%91%E6%9F%90%E4%B9%A0%E9%80%9Aapp%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8F%91%E5%8C%85%E5%8F%82%E6%95%B0%E5%8A%A0%E5%AF%86%E5%88%86%E6%9E%90%E3%80%81%E8%A7%A3%E5%AF%86%E5%92%8C%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86/"}],"tags":[{"name":"frida","slug":"frida","link":"/tags/frida/"},{"name":"决策树","slug":"决策树","link":"/tags/%E5%86%B3%E7%AD%96%E6%A0%91/"},{"name":"实战","slug":"实战","link":"/tags/%E5%AE%9E%E6%88%98/"},{"name":"KNN","slug":"KNN","link":"/tags/KNN/"},{"name":"加密算法","slug":"加密算法","link":"/tags/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"name":"堆排序","slug":"堆排序","link":"/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/"},{"name":"哈希表","slug":"哈希表","link":"/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"objection","slug":"objection","link":"/tags/objection/"},{"name":"选择排序","slug":"选择排序","link":"/tags/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"},{"name":"归并排序","slug":"归并排序","link":"/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"name":"冒泡排序","slug":"冒泡排序","link":"/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"},{"name":"并查集","slug":"并查集","link":"/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"归一化","slug":"归一化","link":"/tags/%E5%BD%92%E4%B8%80%E5%8C%96/"},{"name":"js逆向","slug":"js逆向","link":"/tags/js%E9%80%86%E5%90%91/"},{"name":"c++","slug":"c","link":"/tags/c/"}],"categories":[{"name":"安卓逆向","slug":"安卓逆向","link":"/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"},{"name":"MachineLea","slug":"MachineLea","link":"/categories/MachineLea/"},{"name":"algorithm","slug":"algorithm","link":"/categories/algorithm/"},{"name":"web逆向","slug":"web逆向","link":"/categories/web%E9%80%86%E5%90%91/"}]}