{"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"关于我-Codecat","text":"很高兴你能来我的 Blog 我只是一个写代码的猫君记录自己写代码的瞬间 希望自己越来越好 2021-09-10","link":"/about/index.html"}],"posts":[{"title":"k-NearestNeighbor","text":"KNN 近邻算法的初次实现和做法KNN 概述k-近邻（kNN, k-NearestNeighbor）算法是一种基本分类与回归方法，我们这里只讨论分类问题中的 k-近邻算法。 一句话总结: 近朱者赤近墨者黑！ k 近邻算法实际上利用训练数据集对特征向量空间进行划分，并作为其分类的“模型”。 k 值的选择、距离度量以及分类决策规则是 k 近邻算法的三个基本要素。 KNN 场景电影可以按照题材分类，那么如何区分 动作片 和 爱情片 呢？ 动作片: 打斗次数更多 爱情片: 亲吻次数更多 基于电影中的亲吻、打斗出现的次数，使用 k-近邻算法构造程序，就可以自动划分电影的题材类型。 KNN 原理KNN 工作原理 假设有一个带有标签的样本数据集（训练样本集），其中包含每条数据与所属分类的对应关系。 输入没有标签的新数据后，将新数据的每个特征与样本集中数据对应的特征进行比较。 计算新数据与样本数据集中每条数据的距离。 对求得的所有距离进行排序（从小到大，越小表示越相似）。 取前 k （k 一般小于等于 20 ）个样本数据对应的分类标签。 求 k 个数据中出现次数最多的分类标签作为新数据的分类。 KNN 通俗理解给定一个训练数据集，对新的输入实例，在训练数据集中找到与该实例最邻近的 k 个实例，这 k 个实例的多数属于某个类，就把该输入实例分为这个类。 KNN 算法的特点123优点: 精度高、对异常值不敏感、无数据输入假定缺点: 计算复杂度高、空间复杂度高适用数据范围: 数值型和标称型 KNN 算法初次实验123456789101112131415161718192021222324252627282930313233343536373839404142434445from numpy import *import operatorfrom os import listdirfrom collections import Counter#导入必要模块def createDataSet(): #创建数据集和标签 group = array([[1.0, 1.1], [1.0, 1.0], [0, 0], [0, 0.1]]) labels = ['A', 'A', 'B', 'B'] return group,labelsdef classify0(inX,dataSet,labels,k): #获取源数据矩阵的大小 dataSetSize = dataSet.shape[0] print(dataSetSize) print(tile(inX,(dataSetSize,1))) #生成矩阵差的值 diffMat = tile(inX,(dataSetSize,1)) - dataSet #取平方 sqDiffMat = diffMat ** 2 #对每一行都求和 sqDistances = sqDiffMat.sum(axis = 1) #对求和进行根号 distances = sqDistances ** 0.5 #根据距离进行排序从小到大进行排序，并且返回排序后的index sortedDisINdicies = distances.argsort() classCount = {} for i in range(k): #获取该元素的标签是什么 voteIlabel = labels[sortedDisINdicies[i]] #每出现一次，将这个标签+1 classCount[voteIlabel] = classCount.get(voteIlabel, 0) + 1 # 利用max函数直接返回字典中value最大的key maxClassCount = max(classCount,key = classCount.get) # 返回类型 return maxClassCountdef test1(): group,labels = createDataSet() display(group) display(labels) print(classify0([0.1,0.1],group,labels,3))test1() 部分文章出自https://github.com/apachecn/AiLearning/blob/master/docs/ml/2.md","link":"/2021/09/26/k-NearestNeighbor/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/09/10/hello-world/"},{"title":"并查集","text":"近似 O(1)的时间复杂度 并查集能解决什么问题？ 如何合并两个集合 如何两个元素在不在同一个区间内 并查集原理？用一棵树来存储整个集合，树根的编号就是整个集合的编号。每个节点存储它的父节点，p[x]代表它的父节点 衍生出问题 如何判断树根？if(p[x] == x) 如何求 x 的编号？while(p[x] != x) x = p[x] 如何合并两个集合，x 代表第一个集合，y 代表第二个集合？p[x] = y 如何优化？每遍历一次，让这个节点直接指向根节点，即可将时间复杂度优化为 O(1); 模版应用836. 合并集合 1234567891011121314151617181920212223242526272829303132import java.util.*;import java.io.*;public class Main{ private static int p[] = new int[100010]; //声明父节点; public static void main(String [] args) throws IOException { Scanner in = new Scanner(new BufferedInputStream(System.in)); BufferedWriter log = new BufferedWriter(new OutputStreamWriter(System.out)); int n = in.nextInt(); for(int i = 1 ; i &lt;= n ; i ++)p[i] = i; int m = in.nextInt(); while(m -- != 0){ String op = in.next(); if(op.equals(&quot;M&quot;)){ int a = in.nextInt(); int b = in.nextInt(); p[find(a)] = find(b); }else{ int a = in.nextInt(); int b = in.nextInt(); if(find(a) == find(b))log.write(&quot;Yes\\n&quot;); else log.write(&quot;No\\n&quot;); } } log.flush(); log.close(); } //查找x节点的父亲 public static int find(int x){ if(p[x] != x) p[x] = find(p[x]); return p[x]; }} 837. 连通块中点的数量同时维护当前区间内，有多少个数量 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.*;import java.io.*;public class Main{ public static int p[] = new int[100010]; public static int size[] = new int[100010]; public static void main(String[] args) throws IOException { Scanner in = new Scanner(new BufferedInputStream(System.in)); BufferedWriter log = new BufferedWriter(new OutputStreamWriter(System.out)); int n = in.nextInt(); int m = in.nextInt(); for(int i = 1 ; i &lt;= n ; i ++){ p[i] = i; size[i] = 1; } while(m -- != 0){ String op = in.next(); if(op.equals(&quot;C&quot;)){ int a = in.nextInt(); int b = in.nextInt(); if(find(a) == find(b)) continue; size[find(b)] += size[find(a)]; p[find(a)] = b; }else if(op.equals(&quot;Q1&quot;)){ int a = in.nextInt(); int b = in.nextInt(); if(find(a) == find(b))log.write(&quot;Yes\\n&quot;); else log.write(&quot;No\\n&quot;); }else{ int k = in.nextInt(); log.write(size[find(k)] + &quot;\\n&quot;); } } log.flush(); log.close(); } public static int find(int x){ if(p[x] != x)p[x] = find(p[x]); return p[x]; }} 240. 食物链 维护当前集合里面到根节点的距离 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import java.io.*;import java.util.*;public class Main{ public static int[] p,d; //p存储父节点 d存储距离 public static void main(String[] args) throws IOException{ Scanner in = new Scanner(new BufferedInputStream(System.in)); BufferedWriter log = new BufferedWriter(new OutputStreamWriter(System.out)); int n = in.nextInt(); int m = in.nextInt(); p = new int[n + 1]; d = new int[n + 1]; int ans = 0 ; //表示假话的个数 for(int i = 1 ; i &lt;= n ; i ++)p[i] = i; while(m -- != 0){ int op = in.nextInt(); int x = in.nextInt(); int y = in.nextInt(); if(x &gt; n || y &gt; n){ ans += 1; continue; } int px = find(x); int py = find(y); switch (op) { case 1 : { //同一个集合中，表示已确立相互关系 if (px == py) { if ((d[x] - d[y])%3 != 0) { ans++; continue; } } //不同集合中，现在建立相互关系 else { d[px] = d[y] - d[x]; p[px] = py; } break; } case 2 : { //同一个集合中，表示已确立相互关系 if (px == py) { //推导出的关系为 （d[x]-d[y]）%3 == 1 则认为x可以吃y //写成（d[x]-d[y]-1）%3 == 0 可以避免余数是负数的问题 //也可以写成（d[x]-d[y]）%3 +3 == 1 //==正确 -&gt; != 错误 if ((d[x] - d[y] - 1) % 3 != 0) { ans++; continue; } } //不同集合中，现在建立相互关系 else { d[px] = d[y] - d[x] + 1; p[px] = py; } break; } default : System.out.print(&quot;--&quot;); } } log.write(ans + &quot; &quot;); log.flush(); log.close(); } public static int find(int x){ if(x != p[x]){ int u = find(p[x]); d[x] += d[p[x]]; p[x] = u; } return p[x]; }}","link":"/2021/09/10/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"title":"堆排序","text":"堆分为小根堆和大根堆（本质上是一颗完全二叉树） 堆可以干什么？ 找到一个集合当中的最小值 删除一个集合当中的最小值 插入一个数 如何调整小根堆或者大根堆？以小根堆为例子 down -&gt; 选择这个数和子节点的最小值进行交换 up -&gt; 选择这个节点与父节点进行交换 如何存储堆？下标从 1 开始 保证了数组子节点的可行性 选择用数组的形式来存储 1 2 3 4 5 6 7 8k 的 子节点为 2k 2k+1 如何手写一个堆 插入一个数：heap[++size] = x; 求集合当中的最小元素：heap[1]; 删除最小的元素：heap[1] = heap[size]; size ++; down(1) //将末尾的元素覆盖到头节点，数组删除头节点是很麻烦的一件事 删除任意一个元素：heap[k] = heap[size]; size ++; down(k); up(k)； 修改任意一个元素：heap[k] = x;up(x);down(x); 保证 down 和 up 只执行一次 模版题838. 堆排序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.util.*;import java.io.*;public class Main{ public static int size = 0; public static int h[]; public static void main(String[] args) throws IOException{ Scanner in = new Scanner(new BufferedInputStream(System.in)); BufferedWriter log = new BufferedWriter(new OutputStreamWriter(System.out)); int n = in.nextInt(); int m = in.nextInt(); size = n; h = new int[n + 1]; for(int i = 1 ; i &lt;= n ; i ++){ h[i] = in.nextInt(); } //初始化小根堆 优化时间复杂度：nlogn -&gt; n for(int i = n/2 ; i != 0 ; i --){ down(i); } while(m -- != 0){ log.write(h[1] + &quot; &quot;); //删除最小值 h[1] = h[size]; size --; down(1); } log.flush(); log.close(); in.close(); } //向下调整小根堆 public static void down(int u){ int t = u; //用t来存储最小值的编号 if(u*2 &lt;= size &amp;&amp; h[u*2] &lt; h[t]) t = u * 2; if(u*2+1 &lt;= size &amp;&amp; h[u*2+1] &lt; h[t]) t = u * 2 + 1; if(t != u){ int c = h[t]; h[t] = h[u]; h[u] = c; down(t); //递归调整最小值 } } //向上调整小根堆 public static void up(int u){ while(u/2 != 0 &amp;&amp; h[u] &lt; h[u / 2]){ int c = h[u]; h[u] = h[u/2]; h[u/2] = c; u /= 2; } }} 839. 模拟堆 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import java.util.*;import java.io.*;class Main{ static BufferedReader read = new BufferedReader(new InputStreamReader(System.in)); static BufferedWriter log = new BufferedWriter(new OutputStreamWriter(System.out)); static int[] h; static int[] ph; //存放第k个插入点的下标 static int[] hp; //存放堆中点的插入次序 static int size; public static void main(String[] args) throws Exception{ int n = Integer.valueOf(read.readLine()); h = new int[n + 1]; ph = new int[n + 1]; hp = new int[n + 1]; size = 0; int m=0; //m用来记录插入的数的个数 while(n-- &gt; 0){ String[] s = read.readLine().split(&quot; &quot;); String op = s[0]; if(&quot;I&quot;.equals(op)){ int x = Integer.valueOf(s[1]); m++; h[++size]=x; ph[m]=size; hp[size]=m; //down(size); up(size); }else if(&quot;PM&quot;.equals(op)) log.write(h[1] + &quot;\\n&quot;); else if(&quot;DM&quot;.equals(op)){ heapSwap(1,size); size--; down(1); }else if(&quot;D&quot;.equals(op)){ int k = Integer.valueOf(s[1]); int u=ph[k]; //这里一定要用u=ph[k]保存第k个插入点的下标 heapSwap(u,size); //因为在此处heapSwap操作后ph[k]的值已经发生 size--; //如果在up,down操作中仍然使用ph[k]作为参数就会发生错误 up(u); down(u); }else if(&quot;C&quot;.equals(op)){ int k = Integer.valueOf(s[1]); int x = Integer.valueOf(s[2]); h[ph[k]]=x; //此处由于未涉及heapSwap操作且下面的up、down操作只会发生一个所以 down(ph[k]); //所以可直接传入ph[k]作为参数 up(ph[k]); } } log.flush(); } //这个交换过程其实有那么些绕 但关键是理解 如果hp[u]=k 则ph[k]=u 的映射关系 //之所以要进行这样的操作是因为 经过一系列操作 堆中的元素并不会保持原有的插入顺序 //从而我们需要对应到原先第K个堆中元素 //如果理解这个原理 那么就能明白其实三步交换的顺序是可以互换 //h,hp,ph之间两两存在映射关系 所以交换顺序的不同对结果并不会产生影响 public static void heapSwap(int u, int v){ swap(h,u,v); swap(hp, u, v); swap(ph, hp[u], hp[v]); } public static void swap(int[] a, int u, int v){ int tmp = a[u]; a[u] = a[v]; a[v] = tmp; } public static void down(int u){ int t = u; if(u * 2 &lt;= size &amp;&amp; h[t] &gt; h[u * 2]) t = u * 2; if(u * 2 + 1 &lt;= size &amp;&amp; h[t] &gt; h[u * 2 + 1]) t = u * 2 + 1; if(u != t){ heapSwap(u, t); down(t); } } public static void up(int u){ if(u / 2 &gt; 0 &amp;&amp; h[u] &lt; h[u / 2]){ heapSwap(u, u / 2); up(u/2); } }}","link":"/2021/09/11/%E5%A0%86%E6%8E%92%E5%BA%8F/"},{"title":"决策树","text":"1.划分数据集1.1 基本概念在度量数据集的无序程度的时候，分类算法除了需要测量信息熵，还需要划分数据集，度量花费数据集的熵，以便判断当前是否正确的划分了数据集。我们将对每个特征数据集划分的结果计算一次信息熵，然后判断按照那个特征划分数据集是最好的划分方式。也就是说，我们依次选取我们数据集当中的所有特征作为我们划定的特征，然后计算选取该特征时的信息增益，当信息增益最大时我们就选取对应信息增益最大的特征作为我们分类的最佳特征。 下面是我们的数据集：我们用 python 语言表示出这个数据集dataSet= [[1, 1, ‘yes’], [1, 1, ‘yes’], [1, 0, ‘no’], [0, 1, ‘no’], [0, 1, ‘no’]]在这个数据集当中有两个特征，就是每个样本的第一列和第二列，最后一列是它们所属的分类。 我们划分数据集是为了计算根据那个特征我们可以得到最大的信息增益，那么根据这个特征来划分数据就是最好的分类方法。 因此我们需要遍历每一个特征，然后计算按照这种划分方式得出的信息增益。信息增益是指数据集在划分数据前后信息的变化量。 1.2 具体操作划分数据集的方式我们首先选取第一个特征的第一个可能取值来筛选信息。然后再选取第一个特征的第二个可能的取值来划分我们的信息。之后我们再选取第二个特征的第一个可能的取值来划分数据集，以此类推。 e.g:[[1, 1, ‘yes’], [1, 1, ‘yes’], [1, 0, ‘no’], [0, 1, ‘no’], [0, 1, ‘no’]]这个是我们的数据集。如果我们选取第一个特征值也就是需不需要浮到水面上才能生存来划分我们的数据，这里生物有两种可能，1 就是需要，0 就是不需要。那么第一个特征的取值就是两种。 如果我们按照第一个特征的第一个可能的取值来划分数据也就是当所有的样本的第一列取 1 的时候满足的样本，那就是如下三个：[1, 1, ‘yes’], [1, 1, ‘yes’], [1, 0, ‘no’]可以理解为这个特征为一条分界线，我们选取完这个特征之后这个特征就要从我们数据集中剔除，因为要把他理解为分界线。那么划分好的数据就是： [[1, ‘yes’], [1, ‘yes’], [0, ‘no’]]如果我们以第一个特征的第二个取值来划分数据集，也就是当所有样本的第二列取 1 的时候满足的样本，那么就是 [[1, 1, ‘yes’], [1, 1, ‘yes’], [0, 1, ‘no’], [0, 1, ‘no’]]那么得到的数据子集就是下面这个样子：[[1,’yes’],[1,’yes’],[1, ‘no’], [1, ‘no’]]因此我们可以很容易的来构建出我们的代码： 下面我们来分析一下这段代码， 代码功能：划分数据集1234567891011def splitDataSet(dataSet,axis,value): #传入三个参数第一个参数是我们的数据集，是一个链表形式的数据集；第二个参数是我们的要依据某个特征来划分数据集retDataSet = [] #由于参数的链表 dataSet 我们拿到的是它的地址，也就是引用，直接在链表上操作会改变它的数值，所以我们新建一格链表来做操作for featVec in dataSet: if featVec[axis] == value: #如果某个特征和我们指定的特征值相等 #除去这个特征然后创建一个子特征 reduceFeatVec = featVec[:axis] reduceFeatVec.extend(featVec[axis+1:]) #将满足条件的样本并且经过切割后的样本都加入到我们新建立的样本中 retDataSet.append(reduceFeatVec)return retDataSet 12345678910111213总的来说，这段代码的功能就是按照某个特征的取值来划分数据集。 为方便您测试实验我们在贴出这段代码： 1234567891011def splitDataSet(dataSet,axis,value): retDataSet = [] for featVec in dataSet: if featVec[axis] == value: reduceFeatVec = featVec[:axis] reduceFeatVec.extend(featVec[axis+1:]) retDataSet.append(reduceFeatVec)return retDataSet#在这里我们可以注意到一个关于链表的操作：#那就是extend 和append 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126import numpy as npimport pandas as pdfrom math import *#构建数据集def createDataset(): dataSet = [[1, 1, 'yes'], [1, 1, 'yes'], [1, 0, 'no'], [0, 1, 'no'], [0, 1, 'no']] labels = ['no surfacing', 'flippers','is fish'] w1 = pd.DataFrame(dataSet,columns = labels) display(w1) return dataSet, labelscreateDataset()def calcShannoEnt(dataset): allnums = len(dataset) labels = {} for data in dataset: datalabel = data[-1] #初始化所有标签 if datalabel not in labels: labels[datalabel] = 0 labels[datalabel] += 1 hx = 0.0 for key in labels: #计算每种决策的概率 px = float(labels[key]/allnums) hx -= px * log(px,2) print(&quot;hx:&quot;,hx); #计算墒 return hxcalcShannoEnt(createDataset()[0])def splitDataSet(dataSet, index, value): retDataSet = [] for featVec in dataSet: # index列为value的数据集【该数据集需要排除index列】 # 判断index列的值是否为value if featVec[index] == value: # reducedFeatVec = featVec[:index] reducedFeatVec.extend(featVec[index+1:]) # [index+1:]表示从跳过 index 的 index+1行，取接下来的数据 # 收集结果值 index列为value的行【该行需要排除index列】 retDataSet.append(reducedFeatVec) #print(retDataSet) return retDataSetsplitDataSet(createDataset()[0],1,1)def chooseBestFeatureToSplit(dataSet): #需要进行多少次判断特征值 nums = len(dataSet[0]) - 1 baseEnt = calcShannoEnt(dataSet) bestInfoGain, bestFeature = 0.0, -1 for i in range(nums): #找出第一个特征值可能取得的值 featList = [example[i] for example in dataSet] print(&quot;featList:&quot;,featList) #将取得的值离散化 取出唯一值 uniqueList = set(featList) print(&quot;uniqueList&quot;,uniqueList) newE = 0.0 for j in uniqueList: #取出划分出来的子集 subDataset = splitDataSet(dataSet,i,j) print(&quot;subDataset:&quot;,subDataset) # 计算概率 prob = len(subDataset)/float(len(dataSet)) # 计算数学期望 newE += prob * calcShannoEnt(subDataset) #计算出信息增益 infoGain = baseEnt - newE print(f&quot;信息增益:{infoGain},特征值:{i}&quot;) if infoGain &gt; bestInfoGain: bestFeature = i bestInfoGain = infoGain #返回最优特征值 return bestFeaturechooseBestFeatureToSplit(createDataset()[0])def createTree(dataSet,labels): classList = [x[-1] for x in dataSet] #如果所有的标签都相同 就返回一个 if classList.count(classList[0]) == len(classList): return classList[0] #如果只有一列 则表明只有一类 if len(dataSet[0]) == 1: return majorityCnt(classList) bestFeat = chooseBestFeatureToSplit(dataSet) bestFeatLabel = labels[bestFeat] #创建决策树 myTree = {bestFeatLabel:{}} #删除同名变量 del(labels[bestFeat]) #选择最优列 作为分类依据 featValues = [x[bestFeat] for x in dataSet] uniqueVals = set(featValues) for i in uniqueVals: #拷贝一个标签labels副本 subLabels = labels[:] myTree[bestFeatLabel][i] = createTree(splitDataSet(dataSet,bestFeat,i),subLabels) return myTreea,b = createDataset()createTree(a,b)def test(moudelTree,featLabels,testVec): index = featLabels.index(list(moudelTree.keys())[0]) key = featLabels[index] val = testVec[index] print(f&quot;key:{key},val:{val}&quot;) newTree = moudelTree[key][val] print(newTree) if isinstance(newTree,dict): test(newTree,featLabels,testVec) else: return vala,b = createDataset()test(createTree(a,b),['no surfacing', 'flippers'],(1,1))","link":"/2021/10/03/%E5%86%B3%E7%AD%96%E6%A0%91/"},{"title":"哈希表","text":"近似 O(1)的时间复杂度 哈希表一般算法中处理的问题 插入一个数 查找一个数 删除一个数 实现哈希表的两种做法拉链法首先选择拉链法来解决问题，拉链法用通俗的话来说，就是数组+单链表的实现选择 hash 函数 将大整数 x 映射成为小整数的 840. 模拟散列表 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 100002;int e[N],ne[N],idx;int h[N];void insert(int x){ int y = (x % N + N) % N; //为了缩小y 同时也避免负数的存在 e[idx] = x; //在每一个数组下面拉出一条链 insert等同于单链表的操作 ne[idx] = h[y]; h[y] = idx++;}bool find(int x){ int y = (x % N + N ) % N; for(int i = h[y] ; i != -1 ; i = ne[i]) if(e[i] == x) return true; return false;}int main(){ int n; cin &gt;&gt; n; memset(h,-1,sizeof h); while(n --){ char op; int k; cin &gt;&gt; op &gt;&gt; k; if(op == 'I')insert(k); else{ if(find(k))puts(&quot;Yes&quot;); else puts(&quot;No&quot;); } } return 0;} 开放寻址法开放寻址法本质也是从前往后插入，比拉链法更简单的是它只需要开一个数组，操作和理解起来相对容易一点。开放寻址法从前往后找找到空的地方插入，如果已经有了就让当前这个位置的加一 840. 模拟散列表 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 200003,null = 0x3f3f3f3f;int h[N];int find(int x){ int t = (x % N + N)%N; while(h[t] != null &amp;&amp; h[t] != x){ t ++; if(t == N)t = 0; } return t;}int main(){ int n; cin &gt;&gt; n; memset(h,0x3f,sizeof h); while(n --){ char op; int x; cin &gt;&gt; op &gt;&gt; x; int k = find(x); if(op == 'I'){ h[k] = x; }else{ if(h[k] == null)puts(&quot;No&quot;); else puts(&quot;Yes&quot;); } } return 0;} 字符串哈希(字符串哈希) O(n)+O(m) 全称字符串前缀哈希法，把字符串变成一个 p 进制数字（哈希值），实现不同的字符串映射到不同的数字。对形如 X1X2X3⋯Xn−1Xn的字符串,采用字符的 ascii 码乘上 P 的次方来计算哈希值。 映射公式 (X1×Pn−1+X2×Pn−2+⋯+Xn−1×P1+Xn×P0)modQ 注意点： 任意字符不可以映射成 0，否则会出现不同的字符串都映射成 0 的情况，比如 A,AA,AAA 皆为 0 冲突问题：通过巧妙设置 P (131 或 13331) , Q (264)的值，一般可以理解为不产生冲突。 问题是比较不同区间的子串是否相同，就转化为对应的哈希值是否相同。求一个字符串的哈希值就相当于求前缀和，求一个字符串的子串哈希值就相当于求部分和。 前缀和公式 h[i+1]=h[i]×P+s[i]i∈[0,n−1]h 为前缀和数组，s 为字符串数组区间和公式 h[l,r]=h[r]−h[l−1]×Pr−l+1 区间和公式的理解: ABCDE 与 ABC 的前三个字符值是一样，只差两位，乘上 P2把 ABC 变为 ABC00，再用 ABCDE - ABC00 得到 DE 的哈希值。 作者：chocolate-emperor链接：https://www.acwing.com/solution/content/24738/来源：AcWing著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 841. 字符串哈希 123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;typedef unsigned long long ULL;const int N = 100010,P = 131;ULL p[N],h[N];ULL get(int l,int r){ return h[r] - h[l-1]*p[r-l+1];}int main(){ int n,m; string str; cin &gt;&gt; n &gt;&gt; m &gt;&gt; str; p[0] = 1; h[0] = 0; for(int i = 1 ; i &lt;= n ; i ++){ p[i] = p[i-1] * P; h[i] = h[i-1] * P + str[i - 1]; } while(m -- != 0){ int l1,r1,l2,r2; cin &gt;&gt; l1 &gt;&gt; r1 &gt;&gt; l2 &gt;&gt; r2; if(get(l1,r1) != get(l2,r2))puts(&quot;No&quot;); else puts(&quot;Yes&quot;); } return 0;}","link":"/2021/09/20/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"title":"排序算法","text":"三种排序[选择，归并，冒泡]选择排序优点：处理小数据的时候很快，时间复杂度(O^2) 选择排序就跟扑克牌一样，从牌堆里面选择一张牌插入到牌中，依次选择手中的牌，把相对较小的插入到其中 1234567891011void insertionSort(int arr[]){ for(int i = 0 ; i &lt; 6 ; i ++){ int key = arr[i]; int j = i - 1; while(j &gt;= 0 &amp;&amp; arr[j] &gt; key){ arr[j + 1] = arr[j]; j --; } arr[j + 1] = key; }} 快速排序时间复杂度为 O(nlogn) 12345678910111213void quick_sort(int q[], int l, int r){ if (l &gt;= r) return; int i = l - 1, j = r + 1, x = q[l + r &gt;&gt; 1]; while (i &lt; j) { do i ++ ; while (q[i] &lt; x); do j -- ; while (q[j] &gt; x); if (i &lt; j) swap(q[i], q[j]); } quick_sort(q, l, j), quick_sort(q, j + 1, r);} 归并排序**时间复杂度 O(n log n) ** 123456789101112131415161718192021222324void mergeSort(int arr[], int l, int r){ if (l &gt;= r) return; int mid = (l + r) / 2; mergeSort(arr, l, mid); mergeSort(arr, mid + 1, r); int k = 0, i = l, j = mid + 1; int tmp[r - l + 1]; while (i &lt;= mid &amp;&amp; j &lt;= r) { if (arr[i] &lt; arr[j]) tmp[k++] = arr[i++]; else tmp[k++] = arr[j++]; } while (i &lt;= mid) tmp[k++] = arr[i++]; while (j &lt;= r) tmp[k++] = arr[j++]; for (i = l, j = 0; i &lt;= r; i++, j++) arr[i] = tmp[j];} 快速排序和快速排序都是分治思想","link":"/2021/09/24/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"title":"归一化","text":"什么是归一化？以实际例子来说，在国家贸易中，各个国家的货币价值不一样，当 A 国想买 10 吨煤的时候，我们一般是先将钱转化为美元，再用美元去买 10 吨煤，这样中间就有了一个标准 归一化有什么用？归一化在处理数学问题和权重问题的时候具有实用的意义，比如说大学生自习室安排问题中，宿舍距各教室路线长短，教室大小，照明质量，满座率等都是影响结果的因素，这些因素本身有一个相对值，但没有一个统一的标准去衡量他们，于是出现了归一化。使每个大因素和小变量之间都有了一个桥梁，合理的去参与到对决策的影响中。","link":"/2021/09/25/%E5%BD%92%E4%B8%80%E5%8C%96/"},{"title":"浅谈c++的深拷贝与浅拷贝","text":"初次见面正如字面意思，深与浅无非是拷贝力度的大小。那么怎么理解深和浅呢？ 深：将拷贝对象的所有属性复制一遍 浅：仅拷贝对象的地址 那么为什么要有浅拷贝与深拷贝呢？ 总的目的来说，浅拷贝是为了提高速率，让程序员可以直接操纵对象地址，不用再花时间与内存去复制一份新的出来。显而易见可以看出浅拷贝是很方便操作的。 既然浅拷贝很好 那么我不防聊一聊它的坏处 浅拷贝的坏处程序在设计的初期，并不希望我们把所有的事情都考虑好，更希望程序在运行的过程中自行的去拓展。例如我们要存储一个学生的信息，难道我们一开始就要把学生的最高使用上限就考虑到么，肯定不是的。所以出现了 new 和 delete 。使用 new 创建的变量会放在计算机内存的一个特定部分，直到 delete 调用后这个变量才会删除。这是 new 和 delete 使用的背景。 例子1234567891011121314151617#ifndef STRNGBAD_H__#define STRNGBAD_H__#include &lt;iostream&gt;class StringBad{private: char *str; int len; static int num_strings;public: StringBad(); StringBad(const char *s); ~StringBad(); friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const StringBad &amp;st);};#endif 1234567891011121314151617181920212223242526272829303132333435#include &lt;cstring&gt;#include &quot;strngbad.h&quot;using std::cout;int StringBad::num_strings = 0;StringBad::StringBad(const char *s){ len = std::strlen(s); str = new char[len + 1]; std::strcpy(str, s); num_strings++; cout &lt;&lt; num_strings &lt;&lt; &quot;: \\&quot;&quot; &lt;&lt; str &lt;&lt; &quot;\\&quot; default object created\\n&quot;;}StringBad::StringBad(){ len = 4; str = new char[4]; std::strcpy(str, &quot;c++&quot;); num_strings++; cout &lt;&lt; num_strings &lt;&lt; &quot;: \\&quot;&quot; &lt;&lt; str &lt;&lt; &quot;\\&quot; default object created\\n&quot;;}StringBad::~StringBad(){ cout &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; str &lt;&lt; &quot;\\&quot; object deleted, &quot;; --num_strings; cout &lt;&lt; num_strings &lt;&lt; &quot;left\\n&quot;; delete[] str;}std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const StringBad &amp;st){ os &lt;&lt; st.str; return os;} main.cpp 123456789101112131415161718192021222324252627282930313233343536373839#include &quot;strngbad.h&quot;using std::cout;using std::endl;void callme1(StringBad &amp;);void callme2(StringBad);int main(){ { cout &lt;&lt; &quot;Start&quot; &lt;&lt; endl; StringBad headline1(&quot;Celery Stalk at Midnight&quot;); StringBad headline2(&quot;Lecttuce Prey&quot;); StringBad sports(&quot;Spinach Leaves Bowl for Dollars&quot;); cout &lt;&lt; &quot;head1&quot; &lt;&lt; headline1 &lt;&lt; endl; callme1(headline1); cout &lt;&lt; &quot;head2&quot; &lt;&lt; headline2 &lt;&lt; endl; callme2(headline2); StringBad sailor = sports; cout &lt;&lt; sailor &lt;&lt; endl; StringBad knot; knot = headline1; cout &lt;&lt; knot &lt;&lt; endl; cout &lt;&lt; &quot;exit&quot;; } cout &lt;&lt; &quot;end main&quot;; return 0;}void callme1(StringBad &amp;rsb){ cout &lt;&lt; &quot;String pass by references:\\n&quot;; cout &lt;&lt; &quot;rsb:&quot; &lt;&lt; rsb &lt;&lt; endl;}void callme2(StringBad sb){ cout &lt;&lt; &quot;String pass by references:\\n&quot;; cout &lt;&lt; &quot;sb:&quot; &lt;&lt; sb &lt;&lt; endl;} 当我们编译之后发现程序并没有错误，可是当程序运行的时候，程序会报错，触发了 GPF 错误（GPF 表示程序试图访问禁止的内存单元）这是一种很坏的现象。 1234567891011121314151617181920Start1: &quot;Celery Stalk at Midnight&quot; default object created2: &quot;Lecttuce Prey&quot; default object created3: &quot;Spinach Leaves Bowl for Dollars&quot; default object createdhead1Celery Stalk at MidnightString pass by references:rsb:Celery Stalk at Midnighthead2Lecttuce PreyString pass by references:sb:Lecttuce Prey&quot;Lecttuce Prey&quot; object deleted, 2leftSpinach Leaves Bowl for Dollars3: &quot;c++&quot; default object createdCelery Stalk at Midnightexit&quot;Celery Stalk at Midnight&quot; object deleted, 2left&quot;Spinach Leaves Bowl for Dollars&quot; object deleted, 1left&quot;@Q�eC#&quot; object deleted, 0lefta.out(14353,0x1048b4580) malloc: *** error for object 0x6000011c5140: pointer being freed was not allocateda.out(14353,0x1048b4580) malloc: *** set a breakpoint in malloc_error_break to debugzsh: abort ./a.out 关于为什么会出现错误呢？1.Private 里的 num_strings 错误这种错误主要是程序调用 c++里的默认拷贝函数，复制了一份新的 StringBad 对象，而 Static 静态类型属于整个类并不属于某个对象，故临时产生的 StringBad 对象也会调用析构函数从而导致 num_strings – 2.@Q�eC# 文字乱码12345StringBad sports;sports = headline1;等同于： sports.str = headline1.str;sports.len = headline1.len; 我们可以发现其中 sports.str 只是指向了 headline1.str 的地址，但是由于 headlline1 在销毁的时候会调用 delete 将 str 从内存中删除掉，从而 sports.str 没有地址可寻. 如何解决？创建复制构造函数 1234567StringBad::StringBad(const StringBad &amp; st){ num_strings ++; len = st.len; str = new char [len + 1]; cout &lt;&lt; num_strings &lt;&lt; &quot;: \\&quot;&quot; &lt;&lt; str &lt;&lt; &quot;\\&quot; object created\\n&quot;;}","link":"/2022/02/13/%E6%B5%85%E8%B0%88c-%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/"},{"title":"FRIDA HOOK AES DES RSA 自吐算法","text":"在分析通信协议的时候 经常遇到的加密算法就是那几个 AES DES 3DES RSA 在 hook AES DES RSA 这些常见的加密算法之前这里先看一下 3 个算法的 java 实现 1 AES 加解密 JAVA 代码实现1.1 AES 加密12345678910111213141516//bytesContent 要加密的数据//key **public static byte[] aes_enc(byte[] bytesContent, String key) throws Exception{ //key相关 byte[] raw = key.getBytes(&quot;utf-8&quot;); SecretKeySpec skeySpec = new SecretKeySpec(raw, &quot;AES&quot;); //&quot;算法/模式/补码方式&quot; 初始化cipher Cipher cipher = Cipher.getInstance(&quot;AES/ECB/PKCS5Padding&quot;); cipher.init(Cipher.ENCRYPT_MODE, skeySpec); //执行加密 byte[] enc = cipher.doFinal(bytesContent); return enc;} 1.2 AES 解密12345678910111213141516//bytesContent 要解密的数据//key **public byte[] aes_dec(byte[] bytesContent, String key) throws Exception{ //key相关 byte[] raw = key.getBytes(&quot;utf-8&quot;); SecretKeySpec skeySpec = new SecretKeySpec(raw, &quot;AES&quot;); //&quot;算法/模式/补码方式&quot; 初始化cipher Cipher cipher = Cipher.getInstance(&quot;AES/ECB/PKCS5Padding&quot;); cipher.init(Cipher.DECRYPT_MODE, skeySpec); //执行解密 byte[] dec = cipher.doFinal(bytesContent); return dec;} 这里 AES 加解密的区别只有一点 123//Cipher.DECRYPT_MODE为解密//Cipher.ENCRYPT_MODE 加密cipher.init(Cipher.DECRYPT_MODE, skeySpec) 2. DES 加解密 JAVA 实现代码2.1 DES 加密12345678910111213141516171819private static byte[] des_enc(byte[] data, byte[] key) throws Exception { // 生成一个可信任的随机数源 SecureRandom sr = new SecureRandom(); // 从原始**数据创建DESKeySpec对象 DESKeySpec dks = new DESKeySpec(key); // 创建一个**工厂，然后用它把DESKeySpec转换成SecretKey对象 SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DES&quot;); SecretKey securekey = keyFactory.generateSecret(dks); // Cipher对象实际完成加密操作 Cipher cipher = Cipher.getInstance(&quot;DES&quot;); // 用**初始化Cipher对象 cipher.init(Cipher.ENCRYPT_MODE, securekey, sr); return cipher.doFinal(data);} 2.2 DES 解密12345678910111213141516171819private static byte[] des_dec(byte[] data, byte[] key) throws Exception { // 生成一个可信任的随机数源 SecureRandom sr = new SecureRandom(); // 从原始**数据创建DESKeySpec对象 DESKeySpec dks = new DESKeySpec(key); // 创建一个**工厂，然后用它把DESKeySpec转换成SecretKey对象 SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DES&quot;); SecretKey securekey = keyFactory.generateSecret(dks); // Cipher对象实际完成解密操作 Cipher cipher = Cipher.getInstance(&quot;DES&quot;); // 用**初始化Cipher对象 cipher.init(Cipher.DECRYPT_MODE, securekey, sr); return cipher.doFinal(data);} 这里 DES 加解密的区别只有一点 123//Cipher.DECRYPT_MODE为解密//Cipher.ENCRYPT_MODE 加密cipher.init(Cipher.DECRYPT_MODE, securekey, sr); 3. RSA 加解密 JAVA 代码实现RSA 加解密代码实现1234567891011121314151617181920212223public static void RSA(byte[] bytesData) throws Exception{ //秘钥长度为1024 生成秘钥对 KeyPairGenerator keyPairGenerator=KeyPairGenerator.getInstance(&quot;RSA&quot;); keyPairGenerator.initialize(1024); KeyPair keyPair= keyPairGenerator.generateKeyPair(); //获取公钥 私钥 PublicKey publicKey=keyPair.getPublic(); PrivateKey privateKey=keyPair.getPrivate(); //公钥加密 java默认&quot;RSA&quot;=&quot;RSA/ECB/PKCS1Padding&quot; Cipher cipher=Cipher.getInstance(&quot;RSA&quot;); cipher.init(Cipher.ENCRYPT_MODE, publicKey); byte[] encBytes = cipher.doFinal(bytesData); //私钥解密 java默认&quot;RSA&quot;=&quot;RSA/ECB/PKCS1Padding&quot; Cipher cipher1=Cipher.getInstance(&quot;RSA&quot;); cipher1.init(Cipher.DECRYPT_MODE, privateKey); byte[] decBytes = cipher1.doFinal(encBytes); Log.d(&quot;xxx&quot;,new String(decBytes));} 这里忽略前面 RSA 加解密都需要的生成公钥私钥的部分核心功能代码如下 3.1 RSA 加密代码1234//公钥加密 java默认&quot;RSA&quot;=&quot;RSA/ECB/PKCS1Padding&quot;Cipher cipher=Cipher.getInstance(&quot;RSA&quot;);cipher.init(Cipher.ENCRYPT_MODE, publicKey);byte[] encBytes = cipher.doFinal(bytesData); 3.2 RSA 解密代码1234//私钥解密 java默认&quot;RSA&quot;=&quot;RSA/ECB/PKCS1Padding&quot;Cipher cipher1=Cipher.getInstance(&quot;RSA&quot;);cipher1.init(Cipher.DECRYPT_MODE, privateKey);byte[] decBytes = cipher1.doFinal(encBytes); 这里 RSA 加解密的区别也只有一点 123//Cipher.DECRYPT_MODE为解密 publicKey 公钥加密//Cipher.ENCRYPT_MODE为加密 privateKey 私钥解密cipher.init(Cipher.ENCRYPT_MODE, publicKey); 看了上面的一些代码 这里可以找到一些共性虽然实现处有些区别 但大体架构和使用的 java 接口是可以找到一些规律的 这里出镜率比较高的有 secretKeySpec Cipher.getInstance cipher.init cipher.doFinal DESKeySpec …(后续还有 这里不一一列举) 查阅 java 帮助文档可以发现, 这些 API 都是一些加密算法常用的接口, 那么实现自吐 就是 hook 加密算法常用的 API,打印相关参数,以便于快速的定位算法和相关参数 加密模式等 在网上查找 相关资料 我找到了一份 frida 自吐算法的源码 链接如下https://blog.csdn.net/weixin_34365417/article/details/93088342 看了上面的源码 作者写的还是不错的 而且不仅 hook 了 我上面提到的加密算法 还 hook 了一些消息摘要算法 MAC 家族和 md 家族等 也就是 md5 sha 等通信协议中常用的 hash 算法 另外也有对 IV 这种加密中用到的向量成员的 hook 这里 我修改了下源码修改的部分主要分为下面几点 针对上面的打印堆栈的代码做了修改 修复在高版本 打印堆栈不换行的问题 增加了一些 hook api 把原来的 python 脚本换成了 js 修复一个 bug ui 调整 增加显示 加密模式 解密模式 把原脚本的 dec 结果 改成 str 结果 增加 dofinal str 显示 4 修改后的源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578var N_ENCRYPT_MODE = 1var N_DECRYPT_MODE = 2function showStacks() { var Exception = Java.use(&quot;java.lang.Exception&quot;); var ins = Exception.$new(&quot;Exception&quot;); var straces = ins.getStackTrace(); if (undefined == straces || null == straces) { return; } console.log(&quot;============================= Stack strat=======================&quot;); console.log(&quot;&quot;); for (var i = 0; i &lt; straces.length; i++) { var str = &quot; &quot; + straces[i].toString(); console.log(str); } console.log(&quot;&quot;); console.log(&quot;============================= Stack end=======================\\r\\n&quot;); Exception.$dispose();}//工具相关函数var base64EncodeChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/', base64DecodeChars = new Array((-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), 62, (-1), (-1), (-1), 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, (-1), (-1), (-1), (-1), (-1), (-1), (-1), 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, (-1), (-1), (-1), (-1), (-1), (-1), 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, (-1), (-1), (-1), (-1), (-1));function stringToBase64(e) { var r, a, c, h, o, t; for (c = e.length, a = 0, r = ''; a &lt; c;) { if (h = 255 &amp; e.charCodeAt(a++), a == c) { r += base64EncodeChars.charAt(h &gt;&gt; 2), r += base64EncodeChars.charAt((3 &amp; h) &lt;&lt; 4), r += '=='; break } if (o = e.charCodeAt(a++), a == c) { r += base64EncodeChars.charAt(h &gt;&gt; 2), r += base64EncodeChars.charAt((3 &amp; h) &lt;&lt; 4 | (240 &amp; o) &gt;&gt; 4), r += base64EncodeChars.charAt((15 &amp; o) &lt;&lt; 2), r += '='; break } t = e.charCodeAt(a++), r += base64EncodeChars.charAt(h &gt;&gt; 2), r += base64EncodeChars.charAt((3 &amp; h) &lt;&lt; 4 | (240 &amp; o) &gt;&gt; 4), r += base64EncodeChars.charAt((15 &amp; o) &lt;&lt; 2 | (192 &amp; t) &gt;&gt; 6), r += base64EncodeChars.charAt(63 &amp; t) } return r}function base64ToString(e) { var r, a, c, h, o, t, d; for (t = e.length, o = 0, d = ''; o &lt; t;) { do r = base64DecodeChars[255 &amp; e.charCodeAt(o++)]; while (o &lt; t &amp;&amp; r == -1); if (r == -1) break; do a = base64DecodeChars[255 &amp; e.charCodeAt(o++)]; while (o &lt; t &amp;&amp; a == -1); if (a == -1) break; d += String.fromCharCode(r &lt;&lt; 2 | (48 &amp; a) &gt;&gt; 4); do { if (c = 255 &amp; e.charCodeAt(o++), 61 == c) return d; c = base64DecodeChars[c] } while (o &lt; t &amp;&amp; c == -1); if (c == -1) break; d += String.fromCharCode((15 &amp; a) &lt;&lt; 4 | (60 &amp; c) &gt;&gt; 2); do { if (h = 255 &amp; e.charCodeAt(o++), 61 == h) return d; h = base64DecodeChars[h] } while (o &lt; t &amp;&amp; h == -1); if (h == -1) break; d += String.fromCharCode((3 &amp; c) &lt;&lt; 6 | h) } return d}function hexToBase64(str) { return base64Encode(String.fromCharCode.apply(null, str.replace(/\\r|\\n/g, &quot;&quot;).replace(/([\\da-fA-F]{2}) ?/g, &quot;0x$1 &quot;).replace(/ +$/, &quot;&quot;).split(&quot; &quot;)));}function base64ToHex(str) { for (var i = 0, bin = base64Decode(str.replace(/[ \\r\\n]+$/, &quot;&quot;)), hex = []; i &lt; bin.length; ++i) { var tmp = bin.charCodeAt(i).toString(16); if (tmp.length === 1) tmp = &quot;0&quot; + tmp; hex[hex.length] = tmp; } return hex.join(&quot;&quot;);}function hexToBytes(str) { var pos = 0; var len = str.length; if (len % 2 != 0) { return null; } len /= 2; var hexA = new Array(); for (var i = 0; i &lt; len; i++) { var s = str.substr(pos, 2); var v = parseInt(s, 16); hexA.push(v); pos += 2; } return hexA;}function bytesToHex(arr) { var str = ''; var k, j; for (var i = 0; i &lt; arr.length; i++) { k = arr[i]; j = k; if (k &lt; 0) { j = k + 256; } if (j &lt; 16) { str += &quot;0&quot;; } str += j.toString(16); } return str;}function stringToHex(str) { var val = &quot;&quot;; for (var i = 0; i &lt; str.length; i++) { if (val == &quot;&quot;) val = str.charCodeAt(i).toString(16); else val += str.charCodeAt(i).toString(16); } return val}function stringToBytes(str) { var ch, st, re = []; for (var i = 0; i &lt; str.length; i++) { ch = str.charCodeAt(i); st = []; do { st.push(ch &amp; 0xFF); ch = ch &gt;&gt; 8; } while (ch); re = re.concat(st.reverse()); } return re;}//将byte[]转成String的方法function bytesToString(arr) { var str = ''; arr = new Uint8Array(arr); for (var i in arr) { str += String.fromCharCode(arr[i]); } return str;}function bytesToBase64(e) { var r, a, c, h, o, t; for (c = e.length, a = 0, r = ''; a &lt; c;) { if (h = 255 &amp; e[a++], a == c) { r += base64EncodeChars.charAt(h &gt;&gt; 2), r += base64EncodeChars.charAt((3 &amp; h) &lt;&lt; 4), r += '=='; break } if (o = e[a++], a == c) { r += base64EncodeChars.charAt(h &gt;&gt; 2), r += base64EncodeChars.charAt((3 &amp; h) &lt;&lt; 4 | (240 &amp; o) &gt;&gt; 4), r += base64EncodeChars.charAt((15 &amp; o) &lt;&lt; 2), r += '='; break } t = e[a++], r += base64EncodeChars.charAt(h &gt;&gt; 2), r += base64EncodeChars.charAt((3 &amp; h) &lt;&lt; 4 | (240 &amp; o) &gt;&gt; 4), r += base64EncodeChars.charAt((15 &amp; o) &lt;&lt; 2 | (192 &amp; t) &gt;&gt; 6), r += base64EncodeChars.charAt(63 &amp; t) } return r}function base64ToBytes(e) { var r, a, c, h, o, t, d; for (t = e.length, o = 0, d = []; o &lt; t;) { do r = base64DecodeChars[255 &amp; e.charCodeAt(o++)]; while (o &lt; t &amp;&amp; r == -1); if (r == -1) break; do a = base64DecodeChars[255 &amp; e.charCodeAt(o++)]; while (o &lt; t &amp;&amp; a == -1); if (a == -1) break; d.push(r &lt;&lt; 2 | (48 &amp; a) &gt;&gt; 4); do { if (c = 255 &amp; e.charCodeAt(o++), 61 == c) return d; c = base64DecodeChars[c] } while (o &lt; t &amp;&amp; c == -1); if (c == -1) break; d.push((15 &amp; a) &lt;&lt; 4 | (60 &amp; c) &gt;&gt; 2); do { if (h = 255 &amp; e.charCodeAt(o++), 61 == h) return d; h = base64DecodeChars[h] } while (o &lt; t &amp;&amp; h == -1); if (h == -1) break; d.push((3 &amp; c) &lt;&lt; 6 | h) } return d}//stringToBase64 stringToHex stringToBytes//base64ToString base64ToHex base64ToBytes// hexToBase64 hexToBytes// bytesToBase64 bytesToHex bytesToStringJava.perform(function () { var secretKeySpec = Java.use('javax.crypto.spec.SecretKeySpec'); secretKeySpec.$init.overload('[B', 'java.lang.String').implementation = function (a, b) { showStacks(); var result = this.$init(a, b); console.log(&quot;======================================&quot;); console.log(&quot;算法名：&quot; + b + &quot;|str**:&quot; + bytesToString(a)); console.log(&quot;算法名：&quot; + b + &quot;|Hex**:&quot; + bytesToHex(a)); return result; } var DESKeySpec = Java.use('javax.crypto.spec.DESKeySpec'); DESKeySpec.$init.overload('[B').implementation = function (a) { showStacks(); var result = this.$init(a); console.log(&quot;======================================&quot;); var bytes_key_des = this.getKey(); console.log(&quot;des** |str &quot; + bytesToString(bytes_key_des)); console.log(&quot;des** |hex &quot; + bytesToHex(bytes_key_des)); return result; } DESKeySpec.$init.overload('[B', 'int').implementation = function (a, b) { showStacks(); var result = this.$init(a, b); console.log(&quot;======================================&quot;); var bytes_key_des = this.getKey(); console.log(&quot;des** |str &quot; + bytesToString(bytes_key_des)); console.log(&quot;des** |hex &quot; + bytesToHex(bytes_key_des)); return result; } var mac = Java.use('javax.crypto.Mac'); mac.getInstance.overload('java.lang.String').implementation = function (a) { showStacks(); var result = this.getInstance(a); console.log(&quot;======================================&quot;); console.log(&quot;算法名：&quot; + a); return result; } mac.update.overload('[B').implementation = function (a) { //showStacks(); this.update(a); console.log(&quot;======================================&quot;); console.log(&quot;update:&quot; + bytesToString(a)) } mac.update.overload('[B', 'int', 'int').implementation = function (a, b, c) { //showStacks(); this.update(a, b, c) console.log(&quot;======================================&quot;); console.log(&quot;update:&quot; + bytesToString(a) + &quot;|&quot; + b + &quot;|&quot; + c); } mac.doFinal.overload().implementation = function () { //showStacks(); var result = this.doFinal(); console.log(&quot;======================================&quot;); console.log(&quot;doFinal结果: |str :&quot; + bytesToString(result)); console.log(&quot;doFinal结果: |hex :&quot; + bytesToHex(result)); console.log(&quot;doFinal结果: |base64 :&quot; + bytesToBase64(result)); return result; } mac.doFinal.overload('[B').implementation = function (a) { //showStacks(); var result = this.doFinal(a); console.log(&quot;======================================&quot;); console.log(&quot;doFinal参数: |str :&quot; + bytesToString(a)); console.log(&quot;doFinal结果: |str :&quot; + bytesToString(result)); console.log(&quot;doFinal结果: |hex :&quot; + bytesToHex(result)); console.log(&quot;doFinal结果: |base64 :&quot; + bytesToBase64(result)); return result; } var md = Java.use('java.security.MessageDigest'); md.getInstance.overload('java.lang.String', 'java.lang.String').implementation = function (a, b) { //showStacks(); console.log(&quot;======================================&quot;); console.log(&quot;算法名：&quot; + a); return this.getInstance(a, b); } md.getInstance.overload('java.lang.String').implementation = function (a) { //showStacks(); console.log(&quot;======================================&quot;); console.log(&quot;算法名：&quot; + a); return this.getInstance(a); } md.update.overload('[B').implementation = function (a) { //showStacks(); console.log(&quot;======================================&quot;); console.log(&quot;update:&quot; + bytesToString(a)) return this.update(a); } md.update.overload('[B', 'int', 'int').implementation = function (a, b, c) { //showStacks(); console.log(&quot;======================================&quot;); console.log(&quot;update:&quot; + bytesToString(a) + &quot;|&quot; + b + &quot;|&quot; + c); return this.update(a, b, c); } md.digest.overload().implementation = function () { //showStacks(); console.log(&quot;======================================&quot;); var result = this.digest(); console.log(&quot;digest结果:&quot; + bytesToHex(result)); console.log(&quot;digest结果:&quot; + bytesToBase64(result)); return result; } md.digest.overload('[B').implementation = function (a) { //showStacks(); console.log(&quot;======================================&quot;); console.log(&quot;digest参数:&quot; + bytesToString(a)); var result = this.digest(a); console.log(&quot;digest结果:&quot; + bytesToHex(result)); console.log(&quot;digest结果:&quot; + bytesToBase64(result)); return result; } var ivParameterSpec = Java.use('javax.crypto.spec.IvParameterSpec'); ivParameterSpec.$init.overload('[B').implementation = function (a) { //showStacks(); var result = this.$init(a); console.log(&quot;======================================&quot;); console.log(&quot;iv向量: |str:&quot; + bytesToString(a)); console.log(&quot;iv向量: |hex:&quot; + bytesToHex(a)); return result; } var cipher = Java.use('javax.crypto.Cipher'); cipher.getInstance.overload('java.lang.String').implementation = function (a) { //showStacks(); var result = this.getInstance(a); console.log(&quot;======================================&quot;); console.log(&quot;模式填充:&quot; + a); return result; } cipher.init.overload('int', 'java.security.Key').implementation = function (a, b) { //showStacks(); var result = this.init(a, b); console.log(&quot;======================================&quot;); if (N_ENCRYPT_MODE == a) { console.log(&quot;init | 加密模式&quot;); } else if(N_DECRYPT_MODE == a) { console.log(&quot;init | 解密模式&quot;); } var bytes_key = b.getEncoded(); console.log(&quot;init key:&quot; + &quot;|str**:&quot; + bytesToString(bytes_key)); console.log(&quot;init key:&quot; + &quot;|Hex**:&quot; + bytesToHex(bytes_key)); return result; } cipher.init.overload('int', 'java.security.cert.Certificate').implementation = function (a, b) { //showStacks(); var result = this.init(a, b); console.log(&quot;======================================&quot;); if (N_ENCRYPT_MODE == a) { console.log(&quot;init | 加密模式&quot;); } else if(N_DECRYPT_MODE == a) { console.log(&quot;init | 解密模式&quot;); } return result; } cipher.init.overload('int', 'java.security.Key', 'java.security.spec.AlgorithmParameterSpec').implementation = function (a, b, c) { //showStacks(); var result = this.init(a, b, c); console.log(&quot;======================================&quot;); if (N_ENCRYPT_MODE == a) { console.log(&quot;init | 加密模式&quot;); } else if(N_DECRYPT_MODE == a) { console.log(&quot;init | 解密模式&quot;); } var bytes_key = b.getEncoded(); console.log(&quot;init key:&quot; + &quot;|str**:&quot; + bytesToString(bytes_key)); console.log(&quot;init key:&quot; + &quot;|Hex**:&quot; + bytesToHex(bytes_key)); return result; } cipher.init.overload('int', 'java.security.cert.Certificate', 'java.security.SecureRandom').implementation = function (a, b, c) { //showStacks(); var result = this.init(a, b, c); if (N_ENCRYPT_MODE == a) { console.log(&quot;init | 加密模式&quot;); } else if(N_DECRYPT_MODE == a) { console.log(&quot;init | 解密模式&quot;); } return result; } cipher.init.overload('int', 'java.security.Key', 'java.security.SecureRandom').implementation = function (a, b, c) { //showStacks(); var result = this.init(a, b, c); if (N_ENCRYPT_MODE == a) { console.log(&quot;init | 加密模式&quot;); } else if(N_DECRYPT_MODE == a) { console.log(&quot;init | 解密模式&quot;); } var bytes_key = b.getEncoded(); console.log(&quot;init key:&quot; + &quot;|str**:&quot; + bytesToString(bytes_key)); console.log(&quot;init key:&quot; + &quot;|Hex**:&quot; + bytesToHex(bytes_key)); return result; } cipher.init.overload('int', 'java.security.Key', 'java.security.AlgorithmParameters').implementation = function (a, b, c) { //showStacks(); var result = this.init(a, b, c); if (N_ENCRYPT_MODE == a) { console.log(&quot;init | 加密模式&quot;); } else if(N_DECRYPT_MODE == a) { console.log(&quot;init | 解密模式&quot;); } var bytes_key = b.getEncoded(); console.log(&quot;init key:&quot; + &quot;|str**:&quot; + bytesToString(bytes_key)); console.log(&quot;init key:&quot; + &quot;|Hex**:&quot; + bytesToHex(bytes_key)); return result; } cipher.init.overload('int', 'java.security.Key', 'java.security.AlgorithmParameters', 'java.security.SecureRandom').implementation = function (a, b, c, d) { //showStacks(); var result = this.init(a, b, c, d); if (N_ENCRYPT_MODE == a) { console.log(&quot;init | 加密模式&quot;); } else if(N_DECRYPT_MODE == a) { console.log(&quot;init | 解密模式&quot;); } var bytes_key = b.getEncoded(); console.log(&quot;init key:&quot; + &quot;|str**:&quot; + bytesToString(bytes_key)); console.log(&quot;init key:&quot; + &quot;|Hex**:&quot; + bytesToHex(bytes_key)); return result; } cipher.init.overload('int', 'java.security.Key', 'java.security.spec.AlgorithmParameterSpec', 'java.security.SecureRandom').implementation = function (a, b, c, d) { //showStacks(); var result = this.update(a, b, c, d); if (N_ENCRYPT_MODE == a) { console.log(&quot;init | 加密模式&quot;); } else if(N_DECRYPT_MODE == a) { console.log(&quot;init | 解密模式&quot;); } var bytes_key = b.getEncoded(); console.log(&quot;init key:&quot; + &quot;|str**:&quot; + bytesToString(bytes_key)); console.log(&quot;init key:&quot; + &quot;|Hex**:&quot; + bytesToHex(bytes_key)); return result; } cipher.update.overload('[B').implementation = function (a) { //showStacks(); var result = this.update(a); console.log(&quot;======================================&quot;); console.log(&quot;update:&quot; + bytesToString(a)); return result; } cipher.update.overload('[B', 'int', 'int').implementation = function (a, b, c) { //showStacks(); var result = this.update(a, b, c); console.log(&quot;======================================&quot;); console.log(&quot;update:&quot; + bytesToString(a) + &quot;|&quot; + b + &quot;|&quot; + c); return result; } cipher.doFinal.overload().implementation = function () { //showStacks(); var result = this.doFinal(); console.log(&quot;======================================&quot;); console.log(&quot;doFinal结果: |str :&quot; + bytesToString(result)); console.log(&quot;doFinal结果: |hex :&quot; + bytesToHex(result)); console.log(&quot;doFinal结果: |base64 :&quot; + bytesToBase64(result)); return result; } cipher.doFinal.overload('[B').implementation = function (a) { //showStacks(); var result = this.doFinal(a); console.log(&quot;======================================&quot;); console.log(&quot;doFinal参数: |str :&quot; + bytesToString(a)); console.log(&quot;doFinal结果: |str :&quot; + bytesToString(result)); console.log(&quot;doFinal结果: |hex :&quot; + bytesToHex(result)); console.log(&quot;doFinal结果: |base64 :&quot; + bytesToBase64(result)); return result; } var x509EncodedKeySpec = Java.use('java.security.spec.X509EncodedKeySpec'); x509EncodedKeySpec.$init.overload('[B').implementation = function (a) { //showStacks(); var result = this.$init(a); console.log(&quot;======================================&quot;); console.log(&quot;RSA**:&quot; + bytesToBase64(a)); return result; } var rSAPublicKeySpec = Java.use('java.security.spec.RSAPublicKeySpec'); rSAPublicKeySpec.$init.overload('java.math.BigInteger', 'java.math.BigInteger').implementation = function (a, b) { //showStacks(); var result = this.$init(a, b); console.log(&quot;======================================&quot;); //console.log(&quot;RSA**:&quot; + bytesToBase64(a)); console.log(&quot;RSA**N:&quot; + a.toString(16)); console.log(&quot;RSA**E:&quot; + b.toString(16)); return result; } var KeyPairGenerator = Java.use('java.security.KeyPairGenerator'); KeyPairGenerator.generateKeyPair.implementation = function () { //showStacks(); var result = this.generateKeyPair(); console.log(&quot;======================================&quot;); var str_private = result.getPrivate().getEncoded(); var str_public = result.getPublic().getEncoded(); console.log(&quot;公钥 |hex&quot; + bytesToHex(str_public)); console.log(&quot;私钥 |hex&quot; + bytesToHex(str_private)); return result; } KeyPairGenerator.genKeyPair.implementation = function () { //showStacks(); var result = this.genKeyPair(); console.log(&quot;======================================&quot;); var str_private = result.getPrivate().getEncoded(); var str_public = result.getPublic().getEncoded(); console.log(&quot;公钥 |hex&quot; + bytesToHex(str_public)); console.log(&quot;私钥 |hex&quot; + bytesToHex(str_private)); return result; }});","link":"/2022/06/13/Firda%E7%94%A8%E6%B3%95/"},{"title":"frida基础用法","text":"frida 是一款方便并且易用的跨平台 Hook 工具，使用它不仅可以 Hook Java 写的应用程序，而且还可以 Hook 原生的应用程序。 frida 分客户端环境和服务端环境。在客户端我们可以编写 Python 代码，用于连接远程设备，提交要注入的代码到远程，接受服务端的发来的消息等。在服务端，我们需要用 Javascript 代码注入到目标进程，操作内存数据，给客户端发送消息等操作。我们也可以把客户端理解成控制端，服务端理解成被控端。假如我们要用 PC 来对 Android 设备上的某个进程进行操作，那么 PC 就是客户端，而 Android 设备就是服务端。 1.1 准备 frida 服务端环境本文，服务端在 Android 平台测试。服务端环境准备步骤如下： 根据自己的平台下载 frida 服务端并解压https://github.com/frida/frida/releases frida_server 2. 执行以下命令将服务端推到手机的/data/local/tmp 目录adb push frida-server /data/local/tmp/frida-server 3. 执行以下命令修改 frida-server 文件权限adb shell chmod 777 /data/local/tmp/frida-server 注：Windows 系统执行命令可以在 CMD 中进行；Linux 和 MacOS 执行命令可以在终端中进行。adb 是 Android 一个调试工具，具体安装方法不是本文的重点。 1.2 准备客户端环境在 PC 上安装 Python 的运行环境，安装完成后执行下面的命令安装 frida pip install frida 1.3 客户端命令参数下面是 frida 客户端命令行的参数解释，看一下就好 Usage: frida [options] target Options: --version show program's version number and exit -h, --help show this help message and exit -D ID, --device=ID connect to device with the given ID -U, --usb connect to USB device -R, --remote connect to remote frida-server -H HOST, --host=HOST connect to remote frida-server on HOST -f FILE, --file=FILE spawn FILE -n NAME, --attach-name=NAME attach to NAME -p PID, --attach-pid=PID attach to PID --debug enable the Node.js compatible script debugger --enable-jit enable JIT -l SCRIPT, --load=SCRIPT load SCRIPT -c CODESHARE_URI, --codeshare=CODESHARE_URI load CODESHARE_URI -e CODE, --eval=CODE evaluate CODE -q quiet mode (no prompt) and quit after -l and -e --no-pause automatically start main thread after startup -o LOGFILE, --output=LOGFILE output to log file 如果将一个脚本注入到 Android 目标进程 frida -U -l myhook.js com.xxx.xxxx 参数解释： -U 指定对 USB 设备操作 -l 指定加载一个 Javascript 脚本 最后指定一个进程名，如果想指定进程 pid,用-p选项。正在运行的进程可以用frida-ps -U命令查看 frida 运行过程中，执行%resume重新注入，执行%reload来重新加载脚本；执行exit结束脚本注入 2. Hook Java 方法2.1 载入类Java.use 方法用于声明一个 Java 类，在用一个 Java 类之前首先得声明。比如声明一个 String 类，要指定完整的类名： var StringClass=Java.use(&quot;java.lang.String&quot;); 2.2 修改函数的实现修改一个函数的实现是逆向调试中相当有用的。修改一个函数的实现后，如果这个函数被调用，我们的 Javascript 代码里的函数实现也会被调用。 2.2.1 函数参数类型表示不同的参数类型都有自己的表示方法 对于基本类型，直接用它在 Java 中的表示方法就可以了，不用改变，例如： int short char byte boolean float double long 基本类型数组，用左中括号接上基本类型的缩写 基本类型缩写表示表： 基本类型缩写 booleanZbyteBcharCdoubleDfloatFintIlongJshortS 例如：int[]类型，在重载时要写成[I 任意类，直接写完整类名即可 例如：java.lang.String 对象数组，用左中括号接上完整类名再接上分号 例如：[java.lang.String; 2.2.2 带参数的构造函数修改参数为 byte[]类型的构造函数的实现 ClassName.$init.overload('[B').implementation=function(param){ //do something } 注：ClassName 是使用 Java.use 定义的类;param 是可以在函数体中访问的参数 修改多参数的构造函数的实现 ClassName.$init.overload('[B','int','int').implementation=function(param1,param2,param3){ //do something } 2.2.3 无参数构造函数ClassName.$init.overload().implementation=function(){ //do something } 调用原构造函数 ClassName.$init.overload().implementation=function(){ //do something this.$init(); //do something } 注意：当构造函数(函数)有多种重载形式，比如一个类中有两个形式的 func：void func()和void func(int)，要加上 overload 来对函数进行重载，否则可以省略 overload 2.2.4 一般函数修改函数名为 func，参数为 byte[]类型的函数的实现 ClassName.func.overload('[B').implementation=function(param){ //do something //return ... } 2.2.5 无参数的函数ClassName.func.overload().implementation=function(){ //do something } 注： 在修改函数实现时，如果原函数有返回值，那么我们在实现时也要返回合适的值 ClassName.func.overload().implementation=function(){ //do something return this.func(); } 3. 调用函数和 Java 一样，创建类实例就是调用构造函数，而在这里用$new表示一个构造函数。 var ClassName=Java.use(&quot;com.luoye.test.ClassName&quot;); var instance = ClassName.$new(); 实例化以后调用其他函数 var ClassName=Java.use(&quot;com.luoye.test.ClassName&quot;); var instance = ClassName.$new(); instance.func(); 4. 类型转换用Java.cast方法来对一个对象进行类型转换，如将variable转换成java.lang.String： var StringClass=Java.use(&quot;java.lang.String&quot;); var NewTypeClass=Java.cast(variable,StringClass); 5. Java.available 字段这个字段标记 Java 虚拟机（例如： Dalvik 或者 ART）是否已加载, 操作 Java 任何东西之前，要确认这个值是否为 true 6. Java.perform 方法Java.perform(fn)在 Javascript 代码成功被附加到目标进程时调用，我们核心的代码要在里面写。格式： Java.perform(function(){ //do something... }); 7. 实例讲解有了以上的基础知识，我们就可以进行编写代码了 7.1 修改返回值7.1.1 场景假设有以下的程序，给 isExcellent 方法传入两个值，通过计算，返回一个布尔值，表示是否优秀。默认情况下，它是只会显示是否优秀：false的，因为我们默认传入的数很小: exp1_before public class MainActivity extends AppCompatActivity { private String TAG=&quot;Crackme&quot;; private TextView textView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView =findViewById(R.id.tv); textView.setText(&quot;是否优秀：&quot;+isExcellent(46,54)); } private boolean isExcellent(int chinese, int math){ if( chinese + math &gt;=180){ return true; } else{ return false; } } } 我们编写一个脚本来 Hook isExcellent 函数，使它返回 true，显示为是否优秀：true 对于这种简单的场景，直接修改返回值就可以了，因为只有结果是重要的。 7.1.2 代码想直接返回结果很简单，直接在匿名方法里 return 即可。 if(Java.available){ Java.perform(function(){ var MainActivity = Java.use(&quot;com.luoyesiqiu.crackme.MainActivity&quot;); MainActivity.isExcellent.implementation=function(){ return true; } }); } 将上面的代码保存为：exp1.js 执行adb shell 'su -c /data/local/tmp/frida-server'启动服务端 运行目标 App 执行frida -U -l exp1.js com.luoyesiqiu.crackme注入代码 按返回键返回桌面，再重新打开 App,发现达到预期 在命令行输入exit，回车，停止注入代码 exp1_after 注：这里为什么要打开两次 App？第一打开是为了让 frida 能够找到进程，第二次打开是为了验证结果，即使 Hook 成功了，界面是有缓存的，并不能实时显示 Hook 结果，所以需要重新打开 App 7.2 修改参数7.2.1 场景假设有以下场景，isExcellent 除了返回是否优秀以外，方法的内部还把分数打印出来。 exp2_before public class MainActivity extends AppCompatActivity { private String TAG=&quot;Crackme&quot;; private TextView textView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView =findViewById(R.id.tv); textView.append(&quot;是否优秀：&quot;+isExcellent(46,54)+&quot;\\n&quot;); } private boolean isExcellent(int chinese, int math){ textView.append(&quot;语文+数学总分：&quot;+(chinese+math)+&quot;\\n&quot;); if( chinese + math &gt;=180){ return true; } else{ return false; } } } 这种情况下我们不可能只返回是否优秀吧，显示的总分很低，但是却返回优秀，是很尴尬的…所以我们要修改 isExcellent 方法的参数，使其通过计算打印和返回合理的值。 7.2.2 代码if(Java.available){ Java.perform(function(){ var MainActivity = Java.use(&quot;com.luoyesiqiu.crackme.MainActivity&quot;); MainActivity.isExcellent.overload(&quot;int&quot;,&quot;int&quot;).implementation=function(chinese,math){ return this.isExcellent(95,96); } }); } 上面的代码，通过 overload 方法重载参数，修改 isExcellent 方法实现，并在实现函数里调用原来的方法，得到新的返回值 将上面的代码保存为：exp2.js 执行adb shell 'su -c /data/local/tmp/frida-server'启动服务端（如果上面启动的服务端还开着可省略这一步） 运行目标 App 执行frida -U -l exp2.js com.luoyesiqiu.crackme注入代码 按返回键，再重新打开 App,发现达到预期 在命令行输入exit，回车，停止注入代码 exp2_after 8. 配合 Python 脚本注入在本文刚开始的时候说到，我们可以编写 Python 代码来配合 Javascript 代码注入。下面我们来看看，怎么使用，先看一段代码： # -*- coding: UTF-8 -*- import frida, sys jscode = &quot;&quot;&quot; if(Java.available){ Java.perform(function(){ var MainActivity = Java.use(&quot;com.luoyesiqiu.crackme.MainActivity&quot;); MainActivity.isExcellent.overload(&quot;int&quot;,&quot;int&quot;).implementation=function(chinese,math){ console.log(&quot;[javascript] isExcellent be called.&quot;); send(&quot;isExcellent be called.&quot;); return this.isExcellent(95,96); } }); } &quot;&quot;&quot; def on_message(message, data): if message['type'] == 'send': print(&quot;[*] {0}&quot;.format(message['payload'])) else: print(message) pass # 查找USB设备并附加到目标进程 session = frida.get_usb_device().attach('com.luoyesiqiu.crackme') # 在目标进程里创建脚本 script = session.create_script(jscode) # 注册消息回调 script.on('message', on_message) print('[*] Start attach') # 加载创建好的javascript脚本 script.load() # 读取系统输入 sys.stdin.read() 将上面的代码，保存为exp3.py 执行adb shell 'su -c /data/local/tmp/frida-server'启动服务端（如果上面启动的服务端还开着可省略这一步） 运行目标 App 执行python exp3.py注入代码 按返回键，再重新打开 App,发现达到预期 按Ctrl+C停止脚本和停止注入代码 上面是一段 Python 代码，我们来分析它的步骤： 通过调用frida.get_usb_device()方法来得到一个连接中的 USB 设备（Device 类）实例 调用 Device 类的attach()方法来附加到目标进程并得到一个会话（Session 类）实例，该方法有一个参数，参数是需要注入的进程名或者进程 pid。如果需要 Hook 的代码在 App 的启动期执行，那么在调用 attach 方法前需要先调用 Device 类的spawn()方法，这个方法也有一个参数，参数是进程名，该方法调用后会重启对应的进程，并返回新的进程 pid。得到新的进程 pid 后，我们可以将这个进程 pid 传递给attach()方法来实现附加。 接着调用 Session 类的create_script()方法创建一个脚本，传入需要注入的 javascript 代码并得到 Script 类实例 调用 Script 类的on()方法添加一个消息回调，第一个参数是信号名，乖乖传入message就行，第二个是回调函数 最后调用 Script 类的load()方法来加载刚才创建的脚本。 注：如果想在 javascript 输出日志，可以调用console.log()方法。如果想给客户端发送消息，可以在 javascript 代码里调用send()方法，并在客户端 Python 代码里注册一个消息回调来接收服务端发来的消息。 可以看到，结合 python 代码，使注入更加的灵活了。如果想看 Python 端 frida 模块的代码，可以访问：https://github.com/frida/frida-python/blob/master/frida/core.py 9. 参考 https://www.frida.re/docs/home/","link":"/2022/06/13/frida%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/"},{"title":"【实战】人人直播 password 加密分析","text":"分析搜索 passwordjadx 搜索 “password” 找到地点 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950private void aCv() { SettingManager.bmC().m16156rl(&quot;&quot;); SettingManager.bmC().m16124tV(-1); RSA.init(); aBB(); Variables.account = this.fgV.getText().toString().trim(); Variables.password = this.fgU.getText().toString().trim(); if (Variables.account == null || Variables.account.length() == 0) { Toast.makeText(getActivity(), RenrenApplication.getContext().getResources().getString(C4591R.C4595string.v5_0_1_guide_register_account_no_null), 1).show(); } else if (Variables.password == null || Variables.password.length() == 0) { Toast.makeText(getActivity(), RenrenApplication.getContext().getResources().getString(C4591R.C4595string.v5_0_1_guide_register_password_no_null), 1).show(); } else if (Methods.m13910tM(Variables.account)) { Methods.showToast((CharSequence) getResources().getString(C4591R.C4595string.v5_0_1_guide_register_not_have_china), false); } else if (Methods.m13910tM(Variables.password)) { Methods.showToast((CharSequence) getResources().getString(C4591R.C4595string.v5_0_1_guide_register_pwd_have_china), false); } else { deY = RSA.bNv(); this.f14991n = RSA.bNx(); this.f14990e = RSA.bNw(); if (deY != null) { try { Variables.password = RSA.m10340P(Variables.password, this.f14991n, this.f14990e); RSA.kJi = 1; } catch (Exception e) { e.printStackTrace(); } } else { Variables.password = Md5.toMD5(Variables.password); RSA.kJi = 2; } if (Variables.account == null || Variables.account.length() &lt;= 0 || Variables.password == null || Variables.password.length() &lt;= 0) { return; } if (this.fha == null) { try { this.fha = new Dialog(getActivity()); this.fha.setContentView(C4591R.layout.login_dialog); ((ImageView) this.fha.findViewById(C4591R.C4593id.image)).startAnimation(AnimationUtils.loadAnimation(getActivity(), C4591R.anim.login_dialog_scale)); } catch (Exception unused) { } } this.fha.show(); if (RSA.kJi != 1) { deY = null; } C12919ServiceProvider.m_RSA_login(Variables.account, Variables.password, 1, &quot;&quot;, deY, getActivity(), this.dfg); } } firda hook 和 objections hookhook password MD5 123456789101112Java.perform(function () { var MainActivity = Java.use('com.renren.mobile.utils.Md5') MainActivity.toMD5.implementation = function (arg1) { send('Hook Start...') send('=====================arg1=============') send(arg1) var t = this.toMD5(arg1) send('=====================return=============') send(t) return t }}) hook password RSA 1234567891011121314Java.perform(function () { var MainActivity = Java.use('com.renren.mobile.utils.RSA') MainActivity.P.implementation = function (a, b, c) { send('Hook Start...') send('=====================arg1=============') send(a) send(b) send(c) var t = this.P.apply(this, arguments) send('=====================return=============') send(t) return t }}) 12345678[*] Hook Start Running[*] Hook Start...[*] =====================arg1=============[*] a12345678[*] 9ddcf8c2fea9cdf39ab64ca208a99a13e6a607edaf1250ba105a150bc197fc09[*] 10001[*] =====================return=============[*] 9cdbd2bb1c45dff85eaecf20814911c15e1f1c2a6f1bd2f9bb5c5d06b6338fef","link":"/2022/06/13/%E3%80%90%E5%AE%9E%E6%88%98%E3%80%91%E4%BA%BA%E4%BA%BA%E7%9B%B4%E6%92%AD-password/"}],"tags":[{"name":"KNN","slug":"KNN","link":"/tags/KNN/"},{"name":"并查集","slug":"并查集","link":"/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"堆排序","slug":"堆排序","link":"/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/"},{"name":"决策树","slug":"决策树","link":"/tags/%E5%86%B3%E7%AD%96%E6%A0%91/"},{"name":"哈希表","slug":"哈希表","link":"/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"选择排序","slug":"选择排序","link":"/tags/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"},{"name":"归并排序","slug":"归并排序","link":"/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"name":"冒泡排序","slug":"冒泡排序","link":"/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"},{"name":"归一化","slug":"归一化","link":"/tags/%E5%BD%92%E4%B8%80%E5%8C%96/"},{"name":"c++","slug":"c","link":"/tags/c/"},{"name":"frida","slug":"frida","link":"/tags/frida/"},{"name":"实战","slug":"实战","link":"/tags/%E5%AE%9E%E6%88%98/"}],"categories":[{"name":"MachineLea","slug":"MachineLea","link":"/categories/MachineLea/"},{"name":"algorithm","slug":"algorithm","link":"/categories/algorithm/"},{"name":"安卓逆向","slug":"安卓逆向","link":"/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"},{"name":"逆向","slug":"逆向","link":"/categories/%E9%80%86%E5%90%91/"}]}